*cf3-access*

   Access promises are conditional promises made by the server about file
   objects. The promise has two consequences. For file copy requests, the
   file becomes transferable to the remote client according to the conditions
   specified in the server promise; in other words, if the connection
   encryption requirements are met, and if the client has been granted
   appropriate privileges with maproot (like its NFS counterpart) to be able
   to see file objects not owned by the server process owner.

   The promise has two mutally exclusive attributes admit and deny. Use of
   admit is preferred as mistakes and omissions can easily be made when
   excluding from a group.

   When access is granted to a directory, the promise is automatically given
   about all of its contents and sub-directories. The access promise allows
   overlapping promises to be made, and these are kept on a
   first-come-first-served basis. Thus file objects (promisers) should be
   listed in order of most-specific file first. In this way, specific
   promises will override less specific ones.

       access:

          "/path/file_object"

            admit   = { "hostname", "ipv4_address", "ipv6_address"  };

   Example:

 body server control
 {
 allowconnects         => { "127.0.0.1" , "::1" };
 allowallconnects      => { "127.0.0.1" , "::1" };
 trustkeysfrom         => { "127.0.0.1" , "::1" };
 }

 bundle server access_rules()
 {
 access:

   "/source/directory"
           comment => "Access to file transfer",
           admit   => { "127.0.0.1" };

   # Grant orchestration communication

   "did.*"
           comment => "Access to class context (enterprise)",
     resource_type => "context",
             admit => { "127.0.0.1" };


   "value of my test_scalar, can expand variables here - $(sys.host)"
           comment => "Grant access to the string in quotes, by name test_scalar",
            handle => "test_scalar",
     resource_type => "literal",
             admit => { "127.0.0.1" };

   "XYZ"
           comment => "Grant access to contents of persistent scalar variable XYZ",
     resource_type => "variable",
             admit => { "127.0.0.1" };

   # Client grants access to CFEngine hub access

   "delta"
                comment => "Grant access to cfengine hub to collect report deltas",
          resource_type => "query",
     report_data_select => report_filter,
                  admit => { "127.0.0.1"  };
   "full"
                comment => "Grant access to cfengine hub to collect full report dump",
          resource_type => "query",
     report_data_select => report_filter,
                  admit => { "127.0.0.1"  };

   policy_hub::

   "collect call"
           comment => "Grant access to cfengine client to request the collection of its reports",
     resource_type => "query",
             admit => { "10.1.2.*" };


 }

 body report_data_select report_filter
 {
     variables_include => { "sys..*", "mon..*" };
     variables_exclude => { "sys.host" };
 }

   Entries may be literal addresses of IPv4 or IPv6, or any name registered
   in the POSIX gethostbyname service.

     ----------------------------------------------------------------------

Attributes

  admit

   Description: The admit slist contains host names or IP addresses to grant
   access to file objects.

   Admit promises grant access to file objects on the server. Arguments may
   be IP addresses or hostnames, provided DNS name resolution is active. In
   order to reach this stage, a client must first have passed all of the
   standard connection tests in the control body.

   The lists may contain network addresses in CIDR notation or regular
   expressions to match the IP address or name of the connecting host.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

 access:

   "/home/mark/LapTop"

     admit   => { "127.0.0.1", "192.168.0.1/24", ".*\.domain\.tld"  };

  deny

   Description: The deny slist contains host names or IP addresses to deny
   access to file objects.

   Denial is for special exceptions. A better strategy is always to grant on
   a need to know basis. A security policy based on exceptions is a weak one.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

 bundle server access_rules()
 {
 access:

   "/path"

     admit   => { ".*\.example\.org" },
     deny    => { "badhost_1\.example\.org", "badhost_1\.example\.org" };
 }

   Notes: Only regular expressions or exact matches are allowed in this list,
   as non-specific matches are too greedy for denial.

  maproot

   Description: The maproot slist contains host names or IP addresses to
   grant full read-privilege on the server.

   Normally users authenticated by the server are granted access only to
   files owned by them and no-one else. Even if the cf-serverd process runs
   with root privileges on the server side of a client-server connection, the
   client is not automatically granted access to download files owned by
   non-privileged users. If maproot is true then remote root users are
   granted access to all files.

   A typical case where mapping is important is in making backups of many
   user files.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

 access:

  "/home"

        admit => { "backup_host.example.org" },
  ifencrypted => "true",

      # Backup needs to have access to all users

      maproot => { "backup_host.example.org" };

   Notes:

   On Windows, cf-serverd, maproot is required to read files if the
   connecting user does not own the file on the server.

  ifencrypted

   Description: The ifencrypted menu option determines whether the current
   file access promise is conditional on the connection from the client being
   encrypted.

   If this flag is true a client cannot access the file object unless its
   connection is encrypted.

   Type: boolean

   Default value: false

   Example:

 access:

    "/path/file"

     admit     => { ".*\.example\.org" },
     ifencrypted => "true";

  resource_type

   Description: The resource_type is the type of object being granted access.

   By default, access to resources granted by the server are files. However,
   sometimes it is useful to cache literal strings, hints and data on the
   server for easy access (e.g. the contents of variables or hashed
   passwords). In the case of literal data, the promise handle serves as the
   reference identifier for queries. Queries are instigated by function calls
   by any agent.

   Type: (menu option)

   Allowed input range:

     path
     literal
     context
     query
     variable

   If the resource type is literal, CFEngine will grant access to a literal
   data string. This string is defined either by the promiser itself, but the
   name of the variable is the identifier given by the promise handle of the
   access promise, since the promiser string might be complex.

   If the resource type is variable then the promiser is the name of a
   persistent scalar variable defined on the server-host. Currently
   persistent scalars are only used internally by Enterprise CFEngine to hold
   enumerated classes for orchestration purposes.

   If you want to send the value of a policy defined variable in the server
   host (which for some reason is not available directly through policy on
   the client, e.g. because they have different policies), then you could use
   the following construction:

 access:

   "$(variable_name)"

          handle => "variable_name",
   resource_type => "literal";

   If the resource type is context, the promiser is treated as a regular
   expression to match persistent classes defined on the server host. If
   these are matched by the request from the client, they will be transmitted
   (See Function remoteclassesmatching).

   The term query may also be used in CFEngine Enterprise to query the server
   for data from embedded databases. This is currently for internal use only,
   and is used to grant access to report 'menus'. If the promiser of a query
   request is called collect_calls, this grants access to server peering
   collect-call tunneling.

   Example:

 bundle server access_rules()
 {
 access:

   "value of my test_scalar, can expand variables here - $(sys.host)"
     handle => "test_scalar",
     comment => "Grant access to contents of test_scalar VAR",
     resource_type => "literal",
     admit => { "127.0.0.1" };

   "XYZ"
     resource_type => "variable",
     handle => "XYZ",
     admit => { "127.0.0.1" };


   # On the policy hub

   "collect_calls"
      resource_type => "query",
            admit   => { "127.0.0.1" };

   # On the isolated client in the field


  "delta"
     comment => "Grant access to cfengine hub to collect report deltas",
     resource_type => "query",
           admit   => { "127.0.0.1"  };
   "full"
           comment => "Grant access to cfengine hub to collect full report dump",
     resource_type => "query",
           admit   => { "127.0.0.1"  };
 }

  report_data_select

   This body is only available in CFEngine Enterprise.

   Description: The report_data_select body restricts access to data for the
   specified query types reported to the CFEngine Enterprise Database.

   This body template allows users to control the content of reports
   collected by the Enterprise Database Server, and allows users to strip
   unwanted data (e.g. temporary variables from reporting).

   Report content can be differentiated between hosts that are controlled by
   the class expression on access promiser.

   If more than one select statement applies to the same host, all of them
   are applied.

   Usage of this body is only allowed in conjunction with using resource_type
   => "query", as this is the resource type that is being affected.

   Type: body report_data_select

   Example:

 body report_data_select
 {
     variables_include => { "sys..*" };
     monitoring_exclude => { ".*" };
 }

   History: Introduced in Enterprise 3.5.0

    classes_include

   Description: The classes_include attribute is used to filter content of
   the class report collected by Enterprise Hub, to include classes matching
   specified regular expressions on the list.

   Only classes matching the specified regular expressions on the list will
   be sent back in the report.

   If this attribute is not used, the report content is not reduced.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

 body report_data_select
 {
     classes_include => { "report_only_my_classes_.*" };
 }

   History: Introduced in Enterprise 3.5.0

    classes_exclude

   Description: The classes_exclude attribute is used to filter content of
   the class report collected by Enterprise Hub, to exclude classes matching
   specified regular expressions on the list.

   If this attribute is used in conjunction with classes_include it will
   exclude entries from the subset selected by the include expression.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

 body report_data_select
 {
     classes_exclude => { "my_tmp_class.*" };
 }

   Notes:

   History: Introduced in Enterprise 3.5.0

    variables_include

   Description: The variables_include attribute is used to filter content of
   the variables report collected by Enterprise Hub, to contain only
   variables matching specified regular expressions on the list.

   If the attribute is not used, the report content is not reduced.

   Type: slist

   Allowed input range: (arbitrary string)

   Regular expressions for this attribute use the form
   <scope>.<variable_name>.

   Example:

 body report_data_select
 {
     variables_include => { "my_bundle.my_variable_prefix_.*" };
 }

   History: Introduced in Enterprise 3.5.0

    variables_exclude

   Description: The variables_exclude attribute is used to filter content of
   the variable report collected by Enterprise Hub, to exclude variables
   matching specified regular expression list.

   Type: slist

   Allowed input range: (arbitrary string)

   Regular expressions for this attribute use the form ..

   Example:

 body report_data_select
 {
     variables_exclude => { "my_bundle.tmp_var_test.*" };
 }

   Notes: If this attribute is used in conjunction with variables_include, it
   will exclude entries from the subset selected by the include expression.

   History: Introduced in Enterprise 3.5.0

    promise_notkept_log_include

   Description: The promise_notkept_log_include attribute is used to filter
   content of the not kept log report collected by Enterprise Hub, to contain
   promise handles matching specified regular expressions on the list.

   Only those handles matching the regular expressions on the list will be
   sent back in the report.

   If the attribute is not used, the report content will not be reduced.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

 body report_data_select
 {
     promise_notkept_log_include => { "my_none_important_promises_.*" };
 }

   History: Introduced in Enterprise 3.5.0

    promise_notkept_log_exclude

   Description: The promise_notkept_log_exclude attribute is used to filter
   content of the not kept log report collected by Enterprise Hub, to exclude
   promise handles matching specified regular expressions on the list.

   Only those handles matching regular expression on the list will be
   excluded from the report.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

 body report_data_select
 {
     promise_notkept_log_exclude => { "my_tmp_promise_handle.*" };
 }

   Notes: If this attribute is used in conjunction with the
   promise_notkept_log_include attribute, it will exclude entries from the
   subset selected by the include expression.

   History: Introduced in Enterprise 3.5.0

    promise_repaired_log_include

   Description: The promise_repaired_log_include attribute is used to filter
   content of the repaired log report collected by Enterprise Hub, to include
   regular expressions matched on the list.

   Only those handles matching the regular expression on the list will be
   sent back in the report. If attribute is not used, the report content will
   not be filtered.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

 body report_data_select
 {
     promise_repaired_log_include => { "my_none_important_promises_.*" };
 }

   History: Introduced in Enterprise 3.5.0

    promise_repaired_log_exclude

   Description: The promise_repaired_log_exclude attribute is used to filter
   content of the repaired log report collected by Enterprise Hub, to exclude
   promise handles matching regular expression on the list.

   Only those handles matching regular expression on the list will be
   excluded from the report.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

 body report_data_select
 {
     promise_repaired_log_exclude => { "my_tmp_promise_handle.*" };
 }

   Notes: If this attribute is used in conjunction with
   promise_repaired_log_include, it will exclude entries from the subset
   selected by the include expression.

   History: Introduced in Enterprise 3.5.0

    monitoring_include

   Description: The monitoring_include attribute is used to filter content of
   the monitoring report collected by Enterprise Hub, to contain only
   observed objects matching regular expressions on the list.

   Only object names matching regular expression on the list will be sent
   back in the report. If the attribute is not used, the report content will
   not be filtered.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

 body report_data_select
 {
     monitoring_include => { "mem_.*" };
 }

   History: Introduced in Enterprise 3.5.0

    monitoring_exclude

   Description: The monitoring_exclude attribute is used to filter content of
   the monitoring report collected by Enterprise Hub, to exclude observed
   objects matching specified regular expressions on the list.

   Only object names matching regular expression list will be excluded from
   the report.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

 body report_data_select
 {
     monitoring_exclude => { "mem_swap", "mem_freeswap" };
 }

   Notes:

   If this attribute is used in conjunction with monitoring_include it will
   exclude entries from the subset selected by the include expression.

   History: Introduced in Enterprise 3.5.0

   -^
*cf3-methods*

   Methods are compound promises that refer to whole bundles of promises.
   Methods may be parameterized. Methods promises are written in a form that
   is ready for future development. The promiser object is an abstract
   identifier that refers to a collection (or pattern) of lower level objects
   that are affected by the promise-bundle. Since the use of these
   identifiers is for the future, you can simply use any string here for the
   time being.

     methods:

       "any"

          usebundle = method_id("parameter",...);

   Methods are useful for encapsulating repeatedly used configuration issues
   and iterating over parameters. They are implemented as bundles that are
   run inline.

     bundle agent example
     {
       vars:

        "userlist" slist => { "mark", "jeang", "jonhenrik", "thomas", "eben" };

       methods:

        "any" usebundle => subtest("$(userlist)");
     }

     bundle agent subtest(user)
     {
       commands:

        "/bin/echo Fix $(user)";

       reports:

         "Finished doing stuff for $(user)";
     }

   Methods offer powerful ways to encapsulate multiple issues pertaining to a
   set of parameters.

   Because a method is just an encapsulation, there is a subtlety about how
   to interpret a successful method invocation. Before version 3.1.0, a
   method was considered repaired if executed (similar to commands). However,
   this led to unnecessary logging of executions, even if not actual
   encapsulated promise was kept. In version 3.1.0 this has been changed so
   that a method promise is considered kept if the method is expanded. A
   method promise is thus never considered repaired.

   Starting from version 3.1.0, methods may be specified using variables.
   Care should be exercised when using this approach. In order to make the
   function call uniquely classified, CFEngine requires the promiser to
   contain the variable name of the method if the variable is a list.

     bundle agent default
     {
     vars:
         "m" slist  => { "x", "y" };
         "p" string => "myfunction";

     methods:
         "set of $(m)" usebundle => $(m)("one");
         "any"         usebundle => $(p)("two");
     }

     ----------------------------------------------------------------------

Attributes

  inherit

   Description: If true this causes the sub-bundle to inherit the private
   classes of its parent

   Inheriting the variables is unnecessary as the child can always access the
   parent's variables through a qualified reference using its bundle name.
   For example: $(bundle.variable).

   Type: boolean

   Default value: false

   Example:

     bundle agent name
     {
     methods:

       "group name" usebundle => my_method,
                      inherit => "true";
     }


     body edit_defaults example
     {
     inherit => "true";
     }

   History: Was introduced in 3.4.0, Enterprise 3.0.0 (2012)

  usebundle

   Type: bundle agent

  useresult

   Description: Specify the name of a local variable to contain any
   result/return value from the child

   Return values are limited to scalars.

   Type: string

   Allowed input range: `[a-zA-Z0-9_$(){}[].:]+

   Example:

     bundle agent test
     {
     methods:

        "any" usebundle => child,
              useresult => "my_return_var";

     reports:
         "My return was: \"$(my_return_var[1])\" and \"$(my_return_var[2])\"";
     }

     bundle agent child
     {
     reports:
        # Map these indices into the useresult namespace

        "this is a return value" 
           bundle_return_value_index => "1";

        "this is another return value" 
           bundle_return_value_index => "2";
     }

   History: Was introduced in 3.4.0 (2012)

   -^
*cf3-meta*

   Meta-data promises have no internal function. They are intended to be used
   to represent arbitrary information about promise bundles. Formally, meta
   promises are implemented as variables, and the values map to a variable
   context called bundlename_meta. The values can be used as variables and
   will appear in CFEngine Enterprise variable reports.

     bundle agent example
     {    
     meta:

       "bundle_version" string => "1.2.3";
       "works_with_cfengine" slist => "{ 3.4.0, 3.5.0 }";

     reports:

       "Not a local variable: $(bundle_version)";
       "Meta data (variable): $(example_meta.bundle_version)";

     }

   The value of meta data can be of the types string or slist.

   -^
*cf3-measurements*

   These features are available only in CFEngine Enterprise.

   By default,CFEngine's monitoring component cf-monitord records performance
   data about the system. These include process counts, service traffic, load
   average and CPU utilization and temperature when available.

   CFEngine Enterprise extends this in two ways. First it adds a three year
   trend summary based any 'shift'-averages. Second, it adds customizable
   measurements promises to monitor or log very specific user data through a
   generic interface. The end-result is to either generate a periodic time
   series, like the above mentioned values, or to log the results to
   custom-defined reports.

     bundle monitor self_watch
     {
     measurements:

   Promises of type measurement are written just like all other promises
   within a bundle destined for the agent concerned, in this case monitor.
   However, it is not necessary to add them to the bundlesequence, because
   cf-monitord executes all bundles of type monitor.

       # Follow a special process over time
       # using CFEngine's process cache to avoid resampling

        "/var/cfengine/state/cf_rootprocs"

           handle => "monitor_self_watch",
           stream_type => "file",
           data_type => "int",
           history_type => "weekly",
           units => "kB",
           match_value => proc_value(".*cf-monitord.*",
              "root\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+([0-9]+).*");
     }

     body match_value proc_value(x,y)
     {
       select_line_matching => "$(x)";
       extraction_regex => "$(y)";
     }

   It is important to specify a promise handle for measurement promises, as
   the names defined in the handle are used to determine the name of the log
   file or variable to which data will be reported. Log files are created
   under WORKDIR/state. Data that have no history type are stored in a
   special variable context called mon, analogous to the system variables in
   sys. Thus the values may be used in other promises in the form
   $(mon.handle).

     bundle monitor watch_diskspace
     {
       # Discover disk device information
       "/bin/df"

           handle => "free_diskspace_watch",
           stream_type => "pipe",
           data_type => "slist",
           history_type => "static",
           units => "device",
           match_value => file_systems;
           # Update this as often as possible

     }

     body match_value file_systems
     {
       select_line_matching => "/.*";
       extraction_regex => "(.*)";
     }

   The general pattern of these promises is to decide whether the source of
   the information is either a file or pipe, determine the data type
   (integer, string etc.), specify a pattern to match the result in the file
   stream and then specify what to do with the result afterwards.

     ----------------------------------------------------------------------

Attributes

  stream_type

   Description: The datatype being collected.

   CFEngine treats all input using a stream abstraction. The preferred
   interface is files, since they can be read without incurring the cost of a
   process. However pipes from executed commands may also be invoked.

   Type: (menu option)

   Allowed input range:

      pipe
      file

   Example:

 stream_type => "pipe";

  data_type

   Description: The datatype being collected.

   When CFEngine observes data, such as the attached partitions in the
   example above, the datatype determines how that data will be handled.
   Integer and real values, counters etc., are recorded as time-series if the
   history type is 'weekly', or as single values otherwise. If multiple items
   are matched by an observation (e.g. several lines in a file match the
   given regular expression), then these can be made into a list by choosing
   slist, else the first matching item will be selected.

   Type: (menu option)

   Allowed input range:

     counter
     int
     real
     string
     slist

   Example:

   "/bin/df"

       handle => "free_disk_watch",
       stream_type => "pipe",

       data_type => "slist",

       history_type => "static",
       units => "device",
       match_value => file_systems,
       action => sample_min(10,15);

  history_type

   Description: Whether the data can be seen as a time-series or just an
   isolated value

   Type: (menu option)

   Allowed input range:

     * scalar

   A single value, with compressed statistics is retained. The value of the
   data is not expected to change much for the lifetime of the daemon (and so
   will be sampled less often by cf-monitord).

     * static

   A synonym for 'scalar'.

     * log

   The measured value is logged as an infinite time-series in
   \$(sys.workdir)/state.

     * weekly

   A standard CFEngine two-dimensional time average (over a weekly period) is
   retained.

   Example:

  "/proc/meminfo"

       handle => "free_memory_watch",
       stream_type => "file",
       data_type => "int",
       history_type => "weekly",
       units => "kB",
       match_value => free_memory;

  units

   Description: The engineering dimensions of this value or a note about its
   intent used in plots

   This is an arbitrary string used in documentation only.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

    "/var/cfengine/state/cf_rootprocs"

       handle => "monitor_self_watch",
       stream_type => "file",
       data_type => "int",
       history_type => "weekly",
       units => "kB",
       match_value => proc_value(".*cf-monitord.*",

          "root\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+([0-9]+).*");

  match_value

   Type: body match_value

    select_line_matching

   Description: Regular expression for matching line location

   The expression is anchored, meaning it must match a whole line, and not a
   fragment within a line.

   This attribute is mutually exclusive of select_line_number.

   Type: string

   Allowed input range: .*

   Example:

      # Editing

      body location example
      {
      select_line_matching => "Expression match.* whole line";
      }

      # Measurement promises

      body match_value example
      {
      select_line_matching => "Expression match.* whole line";
      }

    select_line_number

   Description: Read from the n-th line of the output (fixed format)

   This is mutually exclusive of select_line_matching.

   Type: int

   Allowed input range: 0,99999999999

   Example:

      body match_value find_line
      {
      select_line_number => "2";
      }

   Notes:

    extraction_regex

   Description: Regular expression that should contain a single
   back-reference for extracting a value.

   A single parenthesized back-reference should be given to lift the value to
   be measured out of the text stream. The regular expression is unanchored,
   meaning it may match a partial string

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body match_value free_memory
      {
      select_line_matching => "MemFree:.*";
      extraction_regex => "MemFree:\s+([0-9]+).*";
      }

    track_growing_file

   Description: If true, CFEngine remembers the position to which is last
   read when opening the file, and resets to the start if the file has since
   been truncated

   This option applies only to file based input streams. If this is true,
   CFEngine treats the file as if it were a log file, growing continuously.
   Thus the monitor reads all new entries since the last sampling time on
   each invocation. In this way, the monitor does not count lines in the log
   file redundantly.

   This makes a log pattern promise equivalent to something like tail -f
   logfile | grep pattern in Unix parlance.

   Type: boolean

   Example:

      bundle monitor watch
      {
      measurements:

         "/home/mark/tmp/file"

               handle => "line_counter",
          stream_type => "file",
            data_type => "counter",
          match_value => scan_log("MYLINE.*"),
         history_type => "log",
               action => sample_rate("0");

      }

      #

      body match_value scan_log(x)
      {
      select_line_matching => "^$(x)$";
      track_growing_file => "true";
      }

      #

      body action sample_rate(x)
      {
      ifelapsed => "$(x)";
      expireafter => "10";
      }

    select_multiline_policy

   Description: Regular expression for matching line location

   This option governs how CFEngine handles multiple matching lines in the
   input stream. It can average or sum values if they are integer or real, or
   use first or last representative samples. If non-numerical data types are
   used only the first match is used.

   Type: (menu option)

   Allowed input range:

     average
     sum
     first
     last

   Example:

      body match_value myvalue(xxx)
      {
       select_line_matching => ".*$(xxx).*";
       extraction_regex => "root\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+(\S+).*";
       select_multiline_policy => "sum";
      }

   History: Was introduced in 3.4.0 (2012)

   -^
*cf3-guest_environments*

   Guest environment promises describe enclosed computing environments that
   can host physical and virtual machines, Solaris zones, grids, clouds or
   other enclosures, including embedded systems. CFEngine will support the
   convergent maintenance of such inner environments in a fixed location,
   with interfaces to an external environment.

   CFEngine currently seeks to add convergence properties to existing
   interfaces for automatic self-healing of guest environments. The current
   implementation integrates with libvirt, supporting host virtualization for
   Xen, KVM, VMWare, etc. Thus CFEngine, running on a virtual host, can
   maintain the state and deployment of virtual guest machines defined within
   the libvirt framework. Guest environment promises are not meant to manage
   what goes on within the virtual guests. For that purpose you should run
   CFEngine directly on the virtual machine, as if it were any other machine.

  site1::

   "unique_name1"

        environment_resources => myresources("2GB","512MB"),
        environment_interface => mymachine("hostname"),
             environment_type => "xen",
             environment_state => "running",
             environment_host => "atlas";

   "unique_name2"

             environment_type => "xen_network",
            environment_state => "create",
             environment_host => "atlas";

   CFEngine currently provides a convergent interface to libvirt.

     ----------------------------------------------------------------------

Attributes

  environment_host

   Description: environment_host is a class indicating which physical node
   will execute this guest machine

   The promise will only apply to the machine with this class set. Thus,
   CFEngine must be running locally on the hypervisor for the promise to take
   effect.

   Type: string

   Allowed input range: [a-zA-Z0-9_]+

   Example:

 guest_environments:

  linux::

  "host1"
                  comment => "Keep this vm suspended",
    environment_resources => myresources,
         environment_type => "kvm",
        environment_state => "suspended",
         environment_host => "ubuntu";

   This attribute is required.

   History: this feature was introduced in Nova 2.0.0 (2010), Community 3.3.0
   (2012)

  environment_interface

   Type: body environment_interface

    env_addresses

   Description: env_addresses is the IP addresses of the environment's
   network interfaces

   The IP addresses of the virtual machine can be overridden here at run
   time.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

      body environment_interface vnet(primary)
      {
      env_name      => "$(this.promiser)";
      env_addresses => { "$(primary)" };

      host1::

        env_network => "default_vnet1";

      host2::

        env_network => "default_vnet2";

      }

    env_name

   Description: env_name is the hostname of the virtual environment.

   The 'hostname' of a virtual guest may or may not be the same as the
   identifier used as 'promiser' by the virtualization manager.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body environment_interface vnet(primary)
      {
      env_name      => "$(this.promiser)";
      env_addresses => { "$(primary)" };

      host1::
        env_network => "default_vnet1";

      host2::
        env_network => "default_vnet2";
      }

    env_network

   Description: The hostname of the virtual network

   Type: string

   Allowed input range: (arbitrary string)

   Example:

     body environment_interface vnet(primary)
     {
     env_name      => "$(this.promiser)";
     env_addresses => { "$(primary)" };

     host1::
       env_network => "default_vnet1";

     host2::
       env_network => "default_vnet2";
     }

  environment_resources

   Type: body enviornment_resources

    env_cpus

   Description: env_cpus represents the number of virtual CPUs in the
   environment.

   The maximum number of cores or processors in the physical environment will
   set a natural limit on this value.

   Type: int

   Allowed input range: 0,99999999999

   Example:

      body environment_resources my_environment
      {
      env_cpus => "2";
      env_memory => "512"; # in KB
      env_disk => "1024";  # in MB
      }

   Notes: This attribute conflicts with env_spec.

    env_memory

   Description: env_memory represents the amount of primary storage (RAM) in
   the virtual environment (in KB).

   The maximum amount of memory in the physical environment will set a
   natural limit on this value.

   Type: int

   Allowed input range: 0,99999999999

   Example:

      body environment_resources my_environment
      {
      env_cpus => "2";
      env_memory => "512"; # in KB
      env_disk => "1024";  # in MB
      }

   Notes: This attribute conflicts with env_spec.

    env_disk

   Description: env_disk represents the amount of secondary storage (DISK) in
   the virtual environment (in KB).

   This parameter is currently unsupported, for future extension.

   Type: int

   Allowed input range: 0,99999999999

   Example:

      body environment_resources my_environment
      {
      env_cpus => "2";
      env_memory => "512"; # in KB
      env_disk => "1024";  # in MB
      }

   Notes: This parameter is currently unsupported, for future extension.

   This attribute conflicts with env_spec.

    env_baseline

   Description: The env_baseline string represents a path to an image with
   which to baseline the virtual environment.

   Type: string

   Allowed input range: "?(/.*)

   Example:

      env_baseline => "/path/to/image";

   Notes: This function is for future development.

    env_spec

   Description: A env_spec string contains a technology specific set of
   promises for the virtual instance.

   This is the preferred way to specify the resources of an environment on
   creation; in other words, when environment_state is create.

   Type: string

   Allowed input range: .*

   Example:

      body environment_resources virt_xml(host)
      {
      env_spec =>

      "domain type='xen'>
        name>$(host)/name>
        os>
          type>linux/type>
          kernel>/var/lib/xen/install/vmlinuz-ubuntu10.4-x86_64/kernel>
          initrd>/var/lib/xen/install/initrd-vmlinuz-ubuntu10.4-x86_64/initrd>
          cmdline> kickstart=http://example.com/myguest.ks /cmdline>
        /os>
        memory>131072/memory>
        vcpu>1/vcpu>
        devices>
          disk type='file'>
            source file='/var/lib/xen/images/$(host).img'/>
            target dev='sda1'/>
          /disk>
          interface type='bridge'>
            source bridge='xenbr0'/>
            mac address='aa:00:00:00:00:11'/>
            script path='/etc/xen/scripts/vif-bridge'/>
          /interface>
          graphics type='vnc' port='-1'/>
          console tty='/dev/pts/5'/>
        /devices>
      /domain>
      ";
      }

   Notes:

   This attribute conflicts with env_cpus, env_memory and env_disk.

   History: Was introduced in version 3.1.0b1,Nova 2.0.0b1 (2010)

  environment_state

   Description: The environment_state defines the desired dynamic state of
   the specified environment.

   Type: (menu option)

   Allowed input range:

     * create

   The guest machine is allocated, installed and left in a running state.

     * delete

   The guest machine is shut down and deallocated, but no files are removed.

     * running

   The guest machine is in a running state, if it previously exists.

     * suspended

   The guest exists in a suspended state or a shutdown state. If the guest is
   running, it is suspended; otherwise it is ignored.

     * down

   The guest machine is shut down, but not deallocated.

   Example:

 guest_environments:

  linux::

  "bishwa-kvm1"
                  comment => "Keep this vm suspended",
    environment_resources => myresources,
         environment_type => "kvm",
        environment_state => "suspended",
         environment_host => "ubuntu";

  environment_type

   Description: environment_type defines the virtual environment type.

   The currently supported types are those supported by libvirt. More will be
   added in the future.

   Type: (menu option)

   Allowed input range:

     xen
     kvm
     esx
     vbox
     test
     xen_net
     kvm_net
     esx_net
     test_net
     zone
     ec2
     eucalyptus

   Example:

 bundle agent my_vm_cloud
 {
 guest_environments:

  scope::

    "vguest1"

        environment_resources => my_environment_template,
        environment_interface => vnet("eth0,192.168.1.100/24"),
        environment_type      => "test",
        environment_state     => "create",
        environment_host      => "atlas";

    "vguest2"

        environment_resources => my_environment_template,
        environment_interface => vnet("eth0,192.168.1.101/24"),
        environment_type      => "test",
        environment_state     => "delete",
        environment_host      => "atlas";
 }

   -^
*cf3-reports*

   Reports promises simply print messages. Outputting a message without
   qualification can be a dangerous operation. In a large installation it
   could unleash an avalanche of messaging.

     reports:

     "literal string or file refererence",
        printfile = printfile_body,
        ...;

   Messages outputted from report promises are prefixed with the letter R to
   distinguish them from other output, for example from commands.

     bundle agent report
     {
     reports:

        "/etc/passwd except $(const.n)"

         # printfile => pr("/etc/passwd","5");

          showstate => { "otherprocs", "rootprocs" };
     }

     ----------------------------------------------------------------------

Attributes

  friend_pattern

   Description: Regular expression to keep selected hosts from the friends
   report list

   This regular expression should match hosts we want to exclude from friend
   reports.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

 reports:
    "Friend status report"
            lastseen => "0",
      friend_pattern => "host1|host2|.*\.domain\.tld";

  intermittency

   Description: Real number threshold [0,1] of intermittency about current
   peers, report above

   Type: real

   Allowed input range: 0,1

   Default value: intermittency => "0"

  printfile

   Description: Outputs the content of a file to standard output

   Type: body printfile

    file_to_print

   Description: Path name to the file that is to be sent to standard output

   Include part of a file in a report.

   Type: string

   Allowed input range: "?(/.*)

    number_of_lines

   Description: Integer maximum number of lines to print from selected file

   Type: int

   Allowed input range: 0,99999999999

   Example:

      bundle agent example
      {
      reports:
          "$(sys.date) - current message of the day:"
             printfile => "motd";
      }

      body printfile motd
      {
          file_to_print   => "/etc/motd";
          number_of_lines => "10";
      }

  report_to_file

   Description: The path and filename to which output should be appended

   Append the output of the report to the named file instead of standard
   output. If the file cannot be opened for writing then the report defaults
   to the standard output.

   Type: string

   Allowed input range: "?(/.*)

   Example:

     bundle agent test
     {
     reports:
        "$(sys.date),This is a report from $(sys.host)"

            report_to_file => "/tmp/test_log";
     }

  bundle_return_value_index

   Description: The promiser is to be interpreted as a literal value that the
   caller can accept as a result for this bundle; in other words, a return
   value with array index defined by this attribute.

   Return values are limited to scalars.

   Type: string

   Allowed input range: [a-zA-Z0-9_$(){}\[\].:]+

   Example:

     body common control
     {
     bundlesequence => { "test" };
     }

     bundle agent test
     {
     methods:

        "any" usebundle => child,
         useresult => "my_return_var";


     reports:
         "My return was: \"$(my_return_var[1])\" and \"$(my_return_var[2])\"";

     }

     bundle agent child
     {
     reports:
        # Map these indices into the useresult namespace

        "this is a return value" 
           bundle_return_value_index => "1";

        "this is another return value" 
           bundle_return_value_index => "2";

     }

  showstate

   Deprecated: This attribute is kept for source compatibility, and has no
   effect.

  lastseen

   Deprecated: This attribute is kept for source compatibility, and has no
   effect.

   -^
*cf3-processes*

   Process promises refer to items in the system process table, i.e., a
   command in some state of execution (with a Process Control Block).
   Promiser objects are patterns that are unanchored, meaning that they match
   line fragments in the system process table.

       processes:

         "regex contained in process line"

             process_select = process_filter_body,
             restart_class = "activation class for process",
             ..;

   Note: Process table formats differ between operating systems, and the use
   of simple patterns such as program-names is recommended. For more
   sophisticated matches, users should use the*process_select*feature.* For
   example, on many systems, the process pattern "^cp" may not match any
   processes, even though "cp" is running. This is because the process table
   entry may list "/bin/cp". However, the process pattern "cp" will also
   match a process containing "scp", so take care not to oversimplify your
   patterns (the PCRE pattern anchors "\b" and "\B" may prove very useful to
   you).

   To restart a process, you must use a class to activate and then describe a
   command in that class.

     commands:

       restart_me::

        "/path/executable" ... ;

   This rationalizes complex restart-commands and avoids unnecessary overlap
   between processes and commands.

   The process_stop is also arguably a command, but it should be an ephemeral
   command that does not lead to a persistent process. It is intended only
   for commands of the form /etc/inetd service stop, not for processes that
   persist. Processes are restarted at the end of a bundle's execution, but
   stop commands are executed immediately.

     bundle agent example
     {
     processes:

      ".*"

         process_count   => anyprocs,
         process_select  => proc_finder;

     reports:

      any_procs::

        "Found processes out of range";
     }

     body process_select proc_finder
     {
       # Processes started between 5.5 hours and 20 minutes ago
       stime_range => irange(ago(0,0,0,5,30,0),ago(0,0,0,0,20,0));
       process_result => "stime";
     }

     body process_count anyprocs
     {
       match_range => "0,0";
       out_of_range_define => { "any_procs" };
     }

  Commands and Processes

   CFEngine distinguishes between processes and commands so that there is a
   clean separation between detection (promises about the process table) and
   certain repairs (promises to execute commands that start processes).

   Command executions are about jobs, services, scripts etc. They are
   properties of an executable file, and the referring 'promiser' is a file
   object. On the other hand a process is a property of a "process
   identifier" which is a kernel instantiation, a quite different object
   altogether. For example:

     * A "PID" (which is not an executable) promises to be reminded of a
       signal, e.g.

     kill signal pid

     * An "command" promises to start or stop itself with a parameterized
       specification.

     exec command argument1 argument2 ...

   Neither the file nor the pid necessarily promise to respond to these
   activations, but they are nonetheless physically meaningful phenomena or
   attributes associated with these objects.

     * Executable files do not listen for signals as they have no active
       state.
     * PIDs do not run themselves or stop themselves with new arguments, but
       they can use signals as they are running.

   Executions lead to processes for the duration of their lifetime, so these
   two issues are related, although the promises themselves are not.

     ----------------------------------------------------------------------

Attributes

  process_count

   Type: body process_count

    in_range_define

   Description: List of classes to define if the matches are in range

   Classes are defined if the processes that are found in the process table
   satisfy the promised process count, in other words if the promise about
   the number of processes matching the other criteria is kept.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

      body process_count example
      {
      in_range_define => { "class1", "class2" };
      }

    match_range

   Description: Integer range for acceptable number of matches for this
   process

   This is a numerical range for the number of occurrences of the process in
   the process table. As long as it falls within the specified limits, the
   promise is considered kept.

   Type: irange[int,int]

   Allowed input range: 0,99999999999

   Example:

      body process_count example
      {
      match_range => irange("10","50");
      }

    out_of_range_define

   Description: List of classes to define if the matches are out of range

   Classes to activate remedial promises conditional on this promise failure
   to be kept.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

      body process_count example(s)
      {
      out_of_range_define => { "process_anomaly", "anomaly_$(s)"};
      }

  process_select

   Type: body process_select

    command

   Description: Regular expression matching the command/cmd field of a
   process

   This expression should match the entire COMMAND field of the process
   table, not just a fragment. This field is usually the last field on the
   line, so it thus starts with the first non-space character and ends with
   the end of line.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body process_select example

      {
      command => "cf-.*";

      process_result => "command";
      }

    pid

   Description: Range of integers matching the process id of a process

   Type: irange[int,int]

   Allowed input range: 0,99999999999

   Example:

      body process_select example
      {
      pid => irange("1","10");
      process_result => "pid";
      }

    pgid

   Description: Range of integers matching the parent group id of a process

   Type: irange[int,int]

   Allowed input range: 0,99999999999

   Example:

      body process_select example
      {
      pgid => irange("1","10");
      process_result => "pgid";
      }

    ppid

   Description: Range of integers matching the parent process id of a process

   Type: irange[int,int]

   Allowed input range: 0,99999999999

   Example:

      body process_select example
      {
      ppid => irange("407","511");
      process_result => "ppid";
      }

    priority

   Description: Range of integers matching the priority field (PRI/NI) of a
   process

   Type: irange[int,int]

   Allowed input range: -20,+20

   Example:

      body process_select example
      {
      priority => irange("-5","0");
      }

    process_owner

   Description: List of regexes matching the user of a process

   The regular expressions should match a legal user name on the system. The
   regex is anchored, meaning it must match the entire name.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

      body process_select example
      {
      process_owner => { "wwwrun", "nobody" };
      }

    process_result

   Description: Boolean class expression with the logical combination of
   process selection criteria

   A logical combination of the process selection classifiers. The syntax is
   the same as that for class expressions. If process_result is not
   specified, then all set attributes in the process_select body are AND'ed
   together.

   Type: string

   Allowed input range:
   [(process_owner|pid|ppid||pgid|rsize|vsize|status|command|ttime|stime|tty|priority|threads)[|!.]*]*

   Example:

      body process_select proc_finder(p)

      {
      process_owner  => { "avahi", "bin" };
      command        => "$(p)";
      pid            => irange("100","199");
      vsize          => irange("0","1000");
      process_result => "command.(process_owner|vsize).!pid";
      }

   See also: file_result

    rsize

   Description: Range of integers matching the resident memory size of a
   process, in kilobytes

   Type: irange[int,int]

   Allowed input range: 0,99999999999

   Example:

      body process_select
      {
      rsize => irange("4000","8000");
      }

    status

   Description: Regular expression matching the status field of a process

   For instance, characters in the set NRSsl+... Windows processes do not
   have status fields.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body process_select example
      {
      status => "Z";
      }

    stime_range

   Description: Range of integers matching the start time of a process

   The calculation of time from process table entries is sensitive to
   Daylight Savings Time (Summer/Winter Time) so calculations could be an
   hour off. This is for now a bug to be fixed.

   Type: irange[int,int]

   Allowed input range: 0,2147483647

   Example:

      body process_select example
      {
      stime_range => irange(ago(0,0,0,1,0,0),now);
      }

    ttime_range

   Description: Range of integers matching the total elapsed time of a
   process.

   This is total accumulated time for a process.

   Type: irange[int,int]

   Allowed input range: 0,2147483647

   Example:

      body process_select example
      {
      ttime_range => irange(0,accumulated(0,1,0,0,0,0));
      }

    tty

   Description: Regular expression matching the tty field of a process

   Windows processes are not regarded as attached to any terminal, so they
   all have tty '?'.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body process_select example
      {
      tty => "pts/[0-9]+";
      }

    threads

   Description: Range of integers matching the threads (NLWP) field of a
   process

   Type: irange[int,int]

   Allowed input range: 0,99999999999

   Example:

      body process_select example
      {
      threads => irange(1,5);
      }

    vsize

   Description: Range of integers matching the virtual memory size of a
   process, in kilobytes.

   On Windows, the virtual memory size is the amount of memory that cannot be
   shared with other processes. In Task Manager, this is called Commit Size
   (Windows 2008), or VM Size (Windows XP).

   Type: irange[int,int]

   Allowed input range: 0,99999999999

   Example:

      body process_select example
      {
      vsize => irange("4000","9000");
      }

  process_stop

   Description: A command used to stop a running process

   As an alternative to sending a termination or kill signal to a process,
   one may call a 'stop script' to perform a graceful shutdown.

   Type: string

   Allowed input range: "?(/.*)

   Example:

     processes:

      "snmpd"

             process_stop => "/etc/init.d/snmp stop";

  restart_class

   Description: A class to be defined globally if the process is not running,
   so that a command: rule can be referred to restart the process

   This is a signal to restart a process that should be running, if it is not
   running. Processes are signaled first and then restarted later, at the end
   of bundle execution, after all possible corrective actions have been made
   that could influence their execution.

   Windows does not support having processes start themselves in the
   background, like Unix daemons usually do; as fork off a child process.
   Therefore, it may be useful to specify an action body that sets background
   to true in a commands promise that is invoked by the class set by
   restart_class. See the commands promise type for more information.

   Type: string

   Allowed input range: [a-zA-Z0-9_$(){}\[\].:]+

   Example:

 processes:

    "cf-serverd"

      restart_class => "start_cfserverd";

 commands:

   start_cfserverd::

     "/var/cfengine/bin/cf-serverd";

  signals

   Description: A list of menu options representing signals to be sent to a
   process.

   Signals are presented as an ordered list to the process. On Windows, only
   the kill signal is supported, which terminates the process.

   Type: (option list)

   Allowed input range:

        hup
        int
        trap
        kill
        pipe
        cont
        abrt
        stop
        quit
        term
        child
        usr1
        usr2
        bus
        segv

   Example:

     processes:

      cfservd_out_of_control::

        "cfservd"

             signals         => { "stop" , "term" },
             restart_class   => "start_cfserv";

      any::

        "snmpd"

             signals         => { "term" , "kill" };

   -^
*cf3-classes*

   Classes promises may be made in any bundle. Classes that are set in common
   bundles are global in scope, while classes in all other bundles are local.

   Note: The term class and context are sometimes used interchangeably.

     bundle common g
     {
     classes:

       "one" expression => "any";

       "client_network" expression => iprange("128.39.89.0/24");
     }

     ----------------------------------------------------------------------

Attributes

  and

   Description: Combine class sources with AND

   The class on the left-hand side is set if all of the class expressions
   listed on the right-hand side are true.

   Type: clist

   Allowed input range: [a-zA-Z0-9_!@@$|.()\[\]{}:]+

   Example:

     classes:

       "compound_class" and => { classmatch("host[0-9].*"), "Monday", "Hr02" };

   Notes:

   If an expression contains a mixture of different object types that need to
   be ANDed together, this list form is more convenient than providing an
   expression.

  dist

   Description: Generate a probabilistic class distribution

   Always set one generic class and one additional class, randomly weighted
   on a probability distribution.

   Type: rlist

   Allowed input range: -9.99999E100,9.99999E100

   Example:

     classes:

       "my_dist" 

         dist => { "10", "20", "40", "50" };

   Notes:

   In the example above the values sum up to 10+20+40+50 = 120. When
   generating the distribution, CFEngine picks a number between 1-120, and
   set the class my_dist as well as one of the following classes:

     my_dist_10 (10/120 of the time)
     my_dist_20 (20/120 of the time)
     my_dist_40 (40/120 of the time)
     my_dist_50 (50/120 of the time)

  expression

   Description: Evaluate string expression of classes in normal form

   Set the class on the left-hand side if the expression on the right-hand
   side evaluates to true.

   Type: class

   Allowed input range: [a-zA-Z0-9_!@@$|.()\[\]{}:]+

   Example:

     classes:

       "class_name" expression => "solaris|(linux.specialclass)";
       "has_toor"   expression => userexists("toor");

  or

   Description: Combine class sources with inclusive OR

   The class on the left-hand side will be set if any one (or more) of the
   class expressions on the right-hand side are true.

   Type: clist

   Allowed input range: [a-zA-Z0-9_!@@$|.()\[\]{}:]+

   Example:

 classes:

     "compound_test"

       or => { classmatch("linux_x86_64_2_6_22.*"), "suse_10_3" };

   Notes:

   This is useful construction for writing expressions that contain
   functions.

  persistence

   Description: Make the class persistent to avoid re-evaluation

   The value specifies time in minutes.

   Type: int

   Allowed input range: 0,99999999999

   Example:

 bundle common setclasses
 {
 classes:

   "cached_classes"
                 or => { "any" },
        persistence => "1";

   "cached_class"
        expression => "any",
        persistence => "1";

 }

   Notes:

   This feature can be used to avoid recomputing expensive classes
   calculations on each invocation. This is useful if a class discovered is
   essentially constant or only slowly varying, such as a hostname or alias
   from a non-standard naming facility.

   For example, to create a conditional inclusion of costly class
   evaluations, put them into a separate bundle in a file classes.cf.

     # promises.cf

     body common control
     {
     peristent_classes::
       bundlesequence => { "test" };

     !peristent_classes::
       bundlesequence => {  "setclasses", "test" };

     !peristent_classes::
       inputs => { "classes.cf" };
     }


     bundle agent test
     {
     reports:

       !my_peristent_class::
        "no peristent class";

       my_peristent_class::
         "peristent class defined";
     }

   Then create classes.cf

     # classes.cf

     bundle common setclasses
     {
     classes:

       "peristent_classes"            # timer flag
              expression => "any",
             persistence => "480";

       "my_peristent_class"
                     or => { ...long list or heavy function... } ,
            persistence => "480";

     }

  not

   Description: Evaluate the negation of string expression in normal form

   The class on the left-hand side will be set if the class expression on the
   right-hand side evaluates to false.

   Type: class

   Allowed input range: [a-zA-Z0-9_!@@$|.()\[\]{}:]+

   Example:

     classes:

        "others"  not => "linux|solaris";
        "no_toor" not => userexists("toor");

   Notes:

   Knowing that something is not the case is not the same as not knowing
   whether something is the case. That a class is not set could mean either.
   See the note on Negative Knowledge.

  scope

   Description: Scope of the class set by this promise.

   Type: (menu option)

   Allowed input range:

     namespace
     bundle

   Default value: namespace

   Example:

     classes:
       "bundle_context"
           scope => "bundle";

   See also: scope in body classes

  select_class

   Description: Select one of the named list of classes to define based on
   host identity

   The class is chosen deterministically (not randomly) but it is not
   possible to say which host will end up in which class in advance. Only
   that hosts will always end up in the same class every time.

   Type: clist

   Allowed input range: [a-zA-Z0-9_!@@$|.()\[\]{}:]+

   Example:

     bundle common g
     {
     classes:
       "selection" select_class => { "one", "two" };

     reports:
       one::
         "One was selected";
       two::
         "Two was selected";
       selection::
          "A selection was made";
     }

   Notes:

   This feature is similar to the splayclass function. However, instead of
   selecting a class for a moment in time, it always chooses one class in the
   list; the same class each time for a given host. This allows hosts to be
   distributed across a controlled list of classes (e.g for load balancing
   purposes).

  xor

   Description: Combine class sources with XOR

   The class on the left-hand side is set if exactly one of the class
   expressions on the right-hand side matches.

   Type: clist

   Allowed input range: [a-zA-Z0-9_!@@$|.()\[\]{}:]+

   Example:

     classes:

      "another_global" xor => { "any", "linux", "solaris"};

   -^
*cf3-storage*

   Storage promises refer to disks and filesystem properties.

       storage:

          "/disk volume or mountpoint"

            volume = volume_body,
            ...;

     bundle agent storage
     {
       storage:

         "/usr" volume  => mycheck("10%");
         "/mnt" mount   => nfs("nfsserv.example.org","/home");

     }

     body volume mycheck(free)   # reusable template

     {
       check_foreign  => "false";
       freespace      => "$(free)";
       sensible_size  => "10000";
       sensible_count => "2";
     }

     body mount nfs(server,source)

     {
       mount_type => "nfs";
       mount_source => "$(source)";
       mount_server => "$(server)";
       edit_fstab => "true";
     }

     ----------------------------------------------------------------------

Attributes

  mount

   Type: body mount

    edit_fstab

   Description: true/false add or remove entries to the file system table
   ("fstab")

   The default behavior is to not place edits in the file system table.

   Type: boolean

   Default value: false

   Example:

      body mount example
      {
        edit_fstab => "true";
      }

    mount_type

   Description: Protocol type of remote file system

   Type: (menu option)

   Allowed input range:

     nfs
     nfs2
     nfs3
     nfs4

   Example:

      body mount example
      {
      mount_type => "nfs3";
      }

   Notes: This field is mainly for future extensions.

    mount_source

   Description: Path of remote file system to mount.

   This is the location on the remote device, server, SAN etc.

   Type: string

   Allowed input range: "?(/.*)

   Example:

      body mount example
      {
      mount_source "/location/disk/directory";
      }

    mount_server

   Description: Hostname or IP or remote file system server.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body mount example
      {
        mount_server => "nfs_host.example.org";
      }

    mount_options

   Description: List of option strings to add to the file system table
   ("fstab").

   This list is concatenated in a form appropriate for the filesystem. The
   options must be legal options for the system mount commands.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

      body mount example
      {
        mount_options => { "rw", "acls" };
      }

    unmount

   Description: true/false unmount a previously mounted filesystem

   Type: boolean

   Default value: false

   Example:

      body mount example
      {
      unmount => "true";
      }

  volume

   Type: body volume

    check_foreign

   Description: If true, verify storage that is mounted from a foreign system
   on this host.

   CFEngine will not normally perform sanity checks on filesystems that are
   not local to the host. If true it will ignore a partition's network
   location and ask the current host to verify storage located physically on
   other systems.

   Type: boolean

   Default value: false

   Example:

      body volume example
      {
        check_foreign  => "true";
      }

    freespace

   Description: Absolute or percentage minimum disk space that should be
   available before warning

   The amount of free space that is promised on a storage device. Once this
   promise is found not to be kept (that is, if the free space falls below
   the promised value), warnings are generated. You may also want to use the
   results of this promise to control other promises.

   Type: string

   Allowed input range: [0-9]+[MBkKgGmb%]

   Example:

      body volume example1
      {
      freespace => "10%";
      }

      body volume example2
      {
      freespace => "50M";
      }

    sensible_size

   Description: Minimum size in bytes that should be used on a
   sensible-looking storage device

   Type: int

   Allowed input range: 0,99999999999

   Example:

      body volume example
      {
      sensible_size => "20K";
      }

    sensible_count

   Description: Minimum number of files that should be defined on a
   sensible-looking storage device.

   Files must be readable by the agent. In other words, it is assumed that
   the agent has privileges on volumes being checked.

   Type: int

   Allowed input range: 0,99999999999

   Example:

      body volume example
      {
      sensible_count => "20";
      }

    scan_arrivals

   Description: If true, generate pseudo-periodic disk change arrival
   distribution.

   This operation should not be left 'on' for more than a single run (maximum
   once per week). It causes CFEngine to perform an extensive disk scan
   noting the schedule of changes between files. This can be used for a
   number of analyses including optimum backup schedule computation.

   Type: boolean

   Default value: false

   Example:

      body volume example
      {
        scan_arrivals => "true";
      }

   -^
*cf3-packages*

   CFEngine supports a generic approach to integration with native operating
   support for packaging. Package promises allow CFEngine to make promises
   regarding the state of software packages conditionally, given the
   assumption that a native package manager will perform the actual
   manipulations. Since no agent can make unconditional promises about
   another, this is the best that can be achieved.

  vars:

   "match_package" slist => {
                            "apache2",
                            "apache2-mod_php5",
                            "apache2-prefork",
                            "php5"
                            };
  packages:

     "$(match_package)"

          package_policy => "add",
          package_method => yum;

   Packages are treated as black-boxes with three labels:

     * A package name
     * A version string
     * An architecture name

   Package managers are treated as black boxes that may support some or all
   of the following promise types:

     * List installed packages
     * Add packages
     * Delete packages
     * Reinstall (repair) packages
     * Update packages
     * Patch packages
     * Verify packages

   If these services are promised by a package manager, cf-agent promises to
   use the service and encapsulate it within the overall CFEngine framework.
   It is possible to set classes based on the return code of a
   package-manager command in a very flexible way. See the kept_returncodes,
   repaired_returncodes and failed_returncodes attributes.

  Domain knowledge

   CFEngine does not maintain operating system specific expert knowledge
   internally, rather it uses a generic model for dealing with promises about
   packages (which depend on the behavior of an external package manager).
   The approach is to define package system details in body-constraints that
   can be written once and for all, for each package system.

   Package promises are like commands promises in the sense that CFEngine
   promises nothing about the outcome of executing a command. All it can
   promise is to interface with it, starting it and using the results in good
   faith. Packages are basically 'outsourced', to invoke IT parlance.

  Behavior

   A package promise consists of a name, a version and an architecture,
   (n,v,a), and behavior to be promised about packages that match criteria
   based on these. The components (n,v,a) can be determined in one of two
   different ways:

     * They may be specified independently, e.g.

      packages:

        "mypackage"

           package_policy => "add",
           package_method => rpm,
           package_select => ">=",
           package_architectures => { "x86_64", "i586" },
           package_version => "1.2.3";

     * They may be extracted from a package identifier (promiser) or
       filename, using pattern matching. For example, a promiser
       7-Zip-4.50-x86_64.msi and a package_method containing the following:

       package_name_regex => "^(\S+)-(\d+\.?)+";
       package_version_regex => "^\S+-((\d+\.?)+)";
       package_arch_regex => "^\S+-[\d\.]+-(.*).msi";

   When scanning a list of installed packages different managers present the
   information (n,v,a) in quite different forms and pattern extraction is
   necessary. When making a promise about a specific package, the CFEngine
   user may choose one or the other model.

  Smart and dumb package systems

   Package managers vary enormously in their capabilities and in the kinds of
   promises they make. There are broadly two types:

     * Smart package systems that resolve dependencies and require only a
       symbolic package name.
     * Dumb package managers that do not resolve dependencies and need
       filename input.

   Normal ordering for packages is the following:

     * Delete
     * Add
     * Update
     * Patch

  Promise repair logic

   Identified package matches version constraints

   Command   Version match 
   add       never         
   delete    =,>=,<=       
   reinstall =,>=,<=       
   upgrade   =,>=,<=       
   patch     =,>=,<=       

   Identified package matched by name, but not version

   Command   Dumb manager Smart manager      
   add       unable       Never              
   delete    unable       Attempt deletion   
   reinstall unable       Attempt delete/add 
   upgrade   unable       Upgrade if capable 
   patch     unable       Patch if capable   

   Package not installed

   Command   Dumb manager             Smart manager       
   add       Attempt to install named Install any version 
   delete    unable                   unable              
   reinstall Attempt to install named unable              
   upgrade   unable                   unable              
   patch     unable                   unable              

     bundle agent packages
     {
     vars:

      # Test the simplest case -- leave everything to the yum smart manager

      "match_package" slist => {
                               "apache2",
                               "apache2-mod_php5",
                               "apache2-prefork",
                               "php5"
                               };
     packages:

       "$(match_package)"

          package_policy => "add",
          package_method => yum;

     }

   Packages promises can be very simple if the package manager is of the
   smart variety that handles details for you. If you need to specify
   architecture and version numbers of packages, this adds some complexity,
   but the options are flexible and designed for maximal adaptability.

  Patching

   Some package systems also support the idea of 'patches'. These might be
   formally different objects to packages. A patch might contain material for
   several packages and be numbered differently. When you select
   patching-policy the package name (promiser) can be a regular expression
   that will match possible patch names, otherwise identifying specific
   patches can be cumbersome.

   Note that patching is a subtle business. There is no simple way using the
   patch settings to install 'all new system patches'.

   If we specify the name of a patch, then CFEngine will try to see if it
   exists and/or is installed. If it exists in the pending list, it will be
   installed. If it exists in the installed list it will not be installed.
   Now consider the pattern .*. This will match any installed package, so
   CFEngine will assume the relevant patch has been installed already. On the
   other hand, the pattern no match will not match an installed patch, but it
   will not match a named patch either.

   Some systems provide a command to do this, which can be specified without
   specific patch arguments. If so, that command can be called periodically
   under commands. The main purposes of patching body items are:

     * To install specific named patches in a controlled manner.
     * To generate reports of available and installed patches during system
       reporting.

  Installers without package/patch arguments

   CFEngine supports the syntax $ at the end of a command to mean that no
   package name arguments should be used or appended after the dollar sign.
   This is because some commands require a list of packages, while others
   require an empty list. The default behavior is to try to append the name
   of one or more packages to the command, depending on whether the policy is
   for individual or bulk installation.

  Default package method

   As of core 3.3.0, if no package_method is defined, CFEngine will look for
   a method called generic. Such a method is defined in the standard library
   for supported operating systems.

Attributes

  package_architectures

   Description: Select the architecture for package selection

   It is possible to specify a list of packages of different architectures if
   it is desirable to install multiple architectures on the host. If no value
   is specified, CFEngine makes no promise about the result; the package
   manager's behavior prevails.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

 packages:

   "$(exact_package)"

      package_policy => "add",
      package_method => rpm,
      package_architectures => { "x86_64" };

  package_method

   Type: body package_method

    package_add_command

   Description: Command to install a package to the system

   This command should install a package when appended with the package
   reference id, formed using the package_name_convention, using the model of
   (name,version,architecture). If package_file_repositories is specified,
   the package reference id will include the full path to a repository
   containing the package.

   Package managers generally expect the name of a package to be passed as a
   parameter. However, in some cases we do not need to pass the name of a
   particular package to the command. Ending the command string with $
   prevents CFEngine from appending the package name to the string.

   Type: string

   Allowed input range: .+

   Example:

      body package_method rpm
      {
      package_add_command => "/bin/rpm -i ";
      }

    package_arch_regex

   Description: Regular expression with one back-reference to extract package
   architecture string

   This is for use when extracting architecture from the name of the
   promiser, when the architecture is not specified using the
   package_architectures list. It is an unanchored regular expression that
   contains exactly one parenthesized back-reference which marks the location
   in the promiser at which the architecture is specified.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method rpm

      {
      package_list_arch_regex    => "[^.]+\.([^.]+)";
      }

   Notes: If no architecture is specified for thegiven package manager, then
   do not define this.

    package_changes

   Description: Defines whether to group packages into a single aggregate
   command.

   This indicates whether the package manager is capable of handling package
   operations with multiple arguments. If this is set to bulk then multiple
   arguments will be passed to the package commands. If set to individual
   packages will be handled one by one. This might add a significant overhead
   to the operations, and also affect the ability of the operating system's
   package manager to handle dependencies.

   Type: (menu option)

   Allowed input range:

       individual
       bulk

   Example:

      body package_method rpm

      {
      package_changes => "bulk";
      }

    package_delete_command

   Description: Command to remove a package from the system

   The command that deletes a package from the system when appended with the
   package reference identifier specified by package_name_convention.

   Package managers generally expect the name of a package to be passed as a
   parameter. However, in some cases we do not need to pass the name of a
   particular package to the command. Ending the command string with $
   prevents CFEngine from appending the package name to the string.

   Type: string

   Allowed input range: .+

   Example:

      body package_method rpm
      {
      package_delete_command => "/bin/rpm -e --nodeps";
      }

    package_delete_convention

   Description: This is how the package manager expects the package to be
   referred to in the deletion part of a package update, e.g. $(name)

   This attribute is used when package_policy is delete, or package_policy is
   update and package_file_repositories is set and package_update_command is
   not set. It is then used to set the pattern for naming the package in the
   way expected by the package manager during the deletion of existing
   packages.

   Three special variables are defined from the extracted data, in a private
   context for use: $(name), $(version) and $(arch). version and arch is the
   version and architecture (if package_list_arch_regex is given) of the
   already installed package. Additionally, if package_file_repositories is
   defined, $(firstrepo) can be prepended to expand the first repository
   containing the package. For example:
   $(firstrepo)$(name)-$(version)-$(arch).msi.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method freebsd

      {
      package_file_repositories => { "/path/to/packages" };
      package_name_convention => "$(name)-$(version).tbz";
      package_delete_convention => "$(name)-$(version)";
      }

   Notes: If this is not defined, it defaults to the value of
   package_name_convention.

    package_file_repositories

   Description: A list of machine-local directories to search for packages

   If specified, CFEngine will assume that the package installation occurs by
   filename and will search the named paths for a package matching the
   pattern package_name_convention. If found the name will be prefixed to the
   package name in the package commands.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

      body package_method filebased
      {
      package_file_repositories => { "/package/repos1", "/packages/repos2" };
      }

    package_installed_regex

   Description: Regular expression which matches packages that are already
   installed

   This regular expression must match complete lines in the output of the
   list command that are actually installed packages. If all the lines match,
   then the regex can be set of .*, however most package systems output
   prefix lines and a variety of human padding that needs to be ignored.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method yum
      {
      package_installed_regex => ".*installed.*";
      }

    package_default_arch_command

   Description: Command to detect the default packages' architecture

   This command allows CFEngine to detect default architecture of packages
   managed by package manager. As an example, multiarch-enabled dpkg only
   lists architectures explicitly for multiarch-enabled packages.

   In case this command is not provided, CFEngine treats all packages without
   explicit architecture set as belonging to implicit default architecture.

   Type: string

   Allowed input range: "?(/.*)

   Example:

      body package_method dpkg
      {
        package_default_arch_command => "/usr/bin/dpkg --print-architecture";

        # ...
      }

   History: Was introduced in 3.4.0, Enterprise 3.0.0 (2012)

    package_list_arch_regex

   Description: Regular expression with one back-reference to extract package
   architecture string

   An unanchored regular expression that contains exactly one parenthesized
   back reference that marks the location in the listed package at which the
   architecture is specified.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method rpm
      {
      package_list_arch_regex    => "[^|]+\|[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
      }

   Notes: If no architecture is specified for the given package manager, then
   do not define this regex.

    package_list_command

   Description: Command to obtain a list of available packages

   This command should provide a complete list of the packages installed on
   the system. It might also list packages that are not installed. Those
   should be filtered out using the package_installed_regex.

   Package managers generally expect the name of a package to be passed as a
   parameter. However, in some cases we do not need to pass the name of a
   particular package to the command. Ending the command string with $
   prevents CFEngine from appending the package name to the string.

   Type: string

   Allowed input range: .+

   Example:

      body package_method rpm

      {
      package_list_command => "/bin/rpm -qa --queryformat \"%{name} %{version}-%{release}\n\"";
      }

    package_list_name_regex

   Description: Regular expression with one back-reference to extract package
   name string

   An unanchored regular expression that contains exactly one parenthesized
   back reference which marks the name of the package from the package
   listing.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method rpm

      {
      package_list_name_regex    => "([^\s]+).*";
      }

    package_list_update_command

   Description: Command to update the list of available packages (if any)

   Not all package managers update their list information from source
   automatically. This command allows a separate update command to be
   executed at intervals determined by package_list_update_ifelapsed.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method xyz
      {
      debian|ubuntu::

      package_list_update_command => "/usr/bin/apt-get update";
      package_list_update_ifelapsed => "240";        # 4 hours
      }

    package_list_update_ifelapsed

   Description: The ifelapsed locking time in between updates of the package
   list

   Type: int

   Allowed input range: -99999999999,9999999999

   Example:

      body package_method xyz
      {
      debian|ubuntu::

      package_list_update_command => "/usr/bin/apt-get update";
      package_list_update_ifelapsed => "240";        # 4 hours
      }

    package_list_version_regex

   Description: Regular expression with one back-reference to extract package
   version string

   This unanchored regular expression should contain exactly one
   parenthesized back-reference that marks the version string of packages
   listed as installed.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method rpm

      {
      package_list_version_regex => "[^\s]+ ([^.]+).*";
      }

    package_name_convention

   Description: This is how the package manager expects the package to be
   referred to, e.g. $(name).$(arch)

   This sets the pattern for naming the package in the way expected by the
   package manager. Three special variables are defined from the extracted
   data, in a private context for use: $(name), $(version) and $(arch).
   Additionally, if package_file_repositories is defined, $(firstrepo) can be
   prepended to expand the first repository containing the package. For
   example: $(firstrepo)$(name)-$(version)-$(arch).msi.

   When package_policy is update, and package_file_repositories is specified,
   package_delete_convention may be used to specify a different convention
   for the delete command.

   If this is not defined, it defaults to the value $(name).

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method rpm
      {
      package_name_convention => "$(name).$(arch).rpm";
      }

    package_name_regex

   Description: Regular expression with one back-reference to extract package
   name string

   This unanchored regular expression is only used when the promiser contains
   not only the name of the package, but its version and architecture also.
   In that case, this expression should contain a single parenthesized
   back-reference to extract the name of the package from the string.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method rpm
      {
      package_name_regex => "([^\s]).*";
      }

    package_noverify_regex

   Description: Regular expression to match verification failure output

   Ananchored regular expression to match output from a package verification
   command. If the output string matches this expression, the package is
   deemed broken.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method xyz

      {
      package_noverify_regex => "Package .* is not installed.*";
      package_verify_command => "/usr/bin/dpkg -s";
      }

    package_noverify_returncode

   Description: Integer return code indicating package verification failure

   For use if a package verification command uses the return code as the
   signal for a failed package verification.

   Type: int

   Allowed input range: -99999999999,9999999999

   Example:

      body package_method xyz
      {
      package_noverify_returncode => "-1";
      package_verify_command => "/bin/rpm -V";
      }

    package_patch_arch_regex

   Description: Anchored regular expression with one back-reference to
   extract update architecture string

   A few package managers keep a separate notion of patches, as opposed to
   package updates. OpenSuSE, for example, is one of these. This provides an
   analogous command struct to the packages for patch updates.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method zypper
      {
      package_patch_arch_regex => "";
      }

    package_patch_command

   Description: Command to update to the latest patch release of an installed
   package

   If the package manager supports patching, this command should patch a
   named package. If only patching of all packages is supported then consider
   running that as a batch operation in commands. Alternatively one can end
   the command string with a $ symbol, which CFEngine will interpret as an
   instruction to not append package names.

   Type: string

   Allowed input range: .+

   Example:

      body package_method zypper

      {
      package_patch_command => "/usr/bin/zypper -non-interactive patch";
      }

    package_patch_installed_regex

   Description: Anchored regular expression which matches packages that are
   already installed

   A few package managers keep a separate notion of patches, as opposed to
   package updates. OpenSuSE, for example, is one of these. This provide an
   analogous command struct to the packages for patch updates.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method zypper
      {
      package_patch_installed_regex => ".*(Installed|Not Applicable).*";
      }

    package_patch_list_command

   Description: Command to obtain a list of available patches or updates

   This command, if it exists at all, is presumed to generate a list of
   patches that are available on the system, in a format analogous to (but
   not necessarily the same as) the package-list command. Patches might
   formally be available in the package manager's view, but if they have
   already been installed, CFEngine will ignore them.

   Package managers generally expect the name of a package to be passed as a
   parameter. However, in some cases we do not need to pass the name of a
   particular package to the command. Ending the command string with $
   prevents CFEngine from appending the package name to the string.

   Type: string

   Allowed input range: .+

   Example:

       package_patch_list_command => "/usr/bin/zypper patches";

    package_patch_name_regex

   Description: Unanchored regular expression with one back-reference to
   extract update name string.

   A few package managers keep a separate notion of patches, as opposed to
   package updates. OpenSuSE, for example, is one of these. This provides an
   analogous command struct to the packages for patch updates.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method zypper
      {
      package_patch_name_regex    => "[^|]+\|\s+([^\s]+).*";
      }

    package_patch_version_regex

   Description: Unanchored regular expression with one back-reference to
   extract update version string.

   A few package managers keep a separate notion of patches, as opposed to
   package updates. OpenSuSE, for example, is one of these. This provides an
   analogous command struct to the packages for patch updates.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method zypper
      {
      package_patch_version_regex => "[^|]+\|[^|]+\|\s+([^\s]+).*";
      }

    package_update_command

   Description: Command to update to the latest version a currently installed
   package

   If supported this should be a command that updates the version of a single
   currently installed package. If only bulk updates are supported, consider
   running this as a single command under commands. The package reference id
   is appended, with the pattern of package_name_convention.

   When package_file_repositories is specified, the package reference id will
   include the full path to a repository containing the package. If
   package_policy is update, and this command is not specified, the
   package_delete_command and package_add_command will be executed to carry
   out the update.

   Type: string

   Allowed input range: .+

   Example:

      body package_method zypper
      {
      package_update_command => "/usr/bin/zypper -non-interactive update";
      }

    package_verify_command

   Description: Command to verify the correctness of an installed package

   If available, this is a command to verify an already installed package. It
   is required only when package_policy is verify.

   The outcome of the command is compared with package_noverify_returncode or
   package_noverify_regex, one of which has to be set when using this
   command. If the package is not installed, the command will not be run the
   promise gets flagged as not kept before the verify command executes.

   In order for the promise to be considered kept, the package must be
   installed, and the verify command must be successful according to
   package_noverify_returncode xor package_noverify_regex.

   Package managers generally expect the name of a package to be passed as a
   parameter. However, in some cases we do not need to pass the name of a
   particular package to the command. Ending the command string with $
   prevents CFEngine from appending the package name to the string.

   Type: string

   Allowed input range: .+

   Example:

      body package_method rpm

      {
      package_verify_command => "/bin/rpm -V";
      package_noverify_returncode => "-1";
      }

    package_version_regex

   Description: Regular expression with one back-reference to extract package
   version string

   If the version of a package is not specified separately using
   package_version, then this should be an unanchored regular expression that
   contains exactly one parenthesized back-reference that matches the version
   string in the promiser.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method rpm
      {
      package_version_regex => "[^\s]+ ([^.]+).*";
      }

    package_multiline_start

   Description: Regular expression which matches the start of a new package
   in multiline output

   This pattern is used in determining when a new package record begins. It
   is used when package managers (like the Solaris package manager) use
   multi-line output formats. This pattern matches the first line of a new
   record.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body package_method solaris (pkgname, spoolfile, adminfile)
      {
      package_changes => "individual";
      package_list_command => "/usr/bin/pkginfo -l";
      package_multiline_start    =>  "\s*PKGINST:\s+[^\s]+";
      ...
      }

    package_commands_useshell

   Description: Whether to use shell for commands in this body

   Type: boolean

   Default value: true

   History: Was introduced in 3.4.0, Nova 2.3.0 (2012)

    package_version_less_command

   Description: Command to check whether first supplied package version is
   less than second one

   This attribute allows overriding of the built-in CFEngine algorithm for
   version comparison, by calling an external command to check whether the
   first passed version is less than another.

   The built-in algorithm does a good approximation of version comparison,
   but different packaging systems differ in corner cases (e.g Debian treats
   symbol ~ less than any other symbol and even less than empty string), so
   some sort of override is necessary.

   Variables v1 and v2 are substituted with the first and second version to
   be compared. Command should return code 0 if v1 is less than v2 and
   non-zero otherwise.

   Note that if package_version_equal_command is not specified, but
   package_version_less_command is, then equality will be tested by issuing
   less comparison twice (v1 equals to v2 if v1 is not less than v2, and v2
   is not less than v1).

   Type: string

   Allowed input range: .+

   Example:

      body package_method deb
      {
      ...
      package_version_less_command => "dpkg --compare-versions ${v1} lt ${v2}";
      }

   History: Was introduced in 3.4.0 (2012)

    package_version_equal_command

   Description: Command to check whether first supplied package version is
   equal to second one

   This attribute allows overriding of the built-in CFEngine algorithm for
   version comparison by calling an external command to check whether the
   passed versions are the same. Some package managers consider textually
   different versions to be the same (e.g. optional epoch component, so
   0:1.0-1 and 1.0-1 versions are the same), and rules for comparing vary
   from package manager to package manager, so override is necessary.

   Variables v1 and v2 are substituted with the versions to be compared.
   Command should return code 0 if versions are equal and non-zero otherwise.

   Note that if package_version_equal_command is not specified, but
   package_version_less_command is, then equality will be tested by issuing
   less comparison twice (v1 equals to v2 if v1 is not less than v2, and v2
   is not less than v1).

   Type: string

   Allowed input range: .+

   Example:

      body package_method deb
      {
      ...
      package_version_equal_command => "dpkg --compare-versions ${v1} eq ${v2}";
      }

   Notes:

   History: Was introduced in 3.4.0 (2012)

  package_policy

   Description: Criteria for package installation/upgrade on the current
   system

   Type: (menu option)

   Allowed input range:

     * add

   Ensure that a package is present (this is the default setting from 3.3.0).

     * delete

   Ensure that a package is not present.

     * reinstall Delete then add package (warning, non-convergent).

     * update

   Update the package if an update is available (manager dependent).

     * addupdate

   Equivalent to add if the package is not installed, and update if it is
   installed.

     * patch

   Install one or more patches if available (manager dependent).

     * verify

   Verify the correctness of the package (manager dependent). The promise is
   kept if the package is installed correctly, not kept otherwise. Requires
   setting package_verify_command.

   Default value: verify

   Example:

 packages:

   "$(match_package)"

      package_policy => "add",
      package_method => xyz;

  package_select

   Description: A criterion for first acceptable match relative to
   package_version

   This selects the operator that compares the promiser to the state of the
   system packages currently installed. If the criterion matches, the policy
   action is scheduled for promise-keeping.

   Type: (menu option)

   Allowed input range:

      <
      >
      ==
      !=
      >=
      <=

   Example:

 packages:

   "$(exact_package)"

      package_policy => "add",
      package_method => xyz,
      package_select => ">=",
      package_architectures => { "x86_64" },
      package_version => "1.2.3-456";

  package_version

   Description: Version reference point for determining promised version

   Used for specifying the targeted package version when the version is
   written separately from the name of the command.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

 packages:

   "mypackage"

      package_policy => "add",
      package_method => rpm,
      package_select => "==",
      package_version => "1.2.3";

   -^
*cf3-vars*

   Variables in CFEngine are defined as promises that an identifier of a
   certain type represents a particular value. Variables can be scalars or
   lists of types string, int or real. Arrays are associative and use square
   brackets [] to enclose an-arbitrary key.

     ----------------------------------------------------------------------

Scalar Variables

  string

   Description: A scalar string

   Type: string

   Allowed input range: (arbitrary string)

   Example:

     vars:

      "xxx"    string => "Some literal string...";
      "yyy"    string => readfile( "/home/mark/tmp/testfile" , "33" );

  int

   Description: A scalar integer

   Type: int

   Allowed input range: -99999999999,9999999999

   Example:

     vars:

      "scalar" int    => "16k";
      "ran"    int    => randomint(4,88);
      "dim_array" int =>  readstringarray("array_name","/etc/passwd","#[^\n]*",":",10,4000);

   Notes:

   Int variables are strings that are expected to be used as integer numbers.
   The typing in CFEngine is dynamic, so the variable types are
   interchangeable. However, when you declare a variable to be type int,
   CFEngine verifies that the value you assign to it looks like an integer
   (e.g., 3, -17, 16K).

  real

   Description: A scalar real number

   Type: real

   Allowed input range: -9.99999E100,9.99999E100

   Example:

     vars:

      "scalar" real   => "0.5";

   Notes:

   Real variables are strings that are expected to be used as real numbers.
   The typing in CFEngine is dynamic, so the variable types are
   interchangeable, but when you declare a variable to be type real, CFEngine
   verifies that the value you assign to it looks like a real number (e.g.,
   3, 3.1415, .17, 6.02e23, -9.21e-17).

   Real numbers are not used in many places in CFEngine, but they are useful
   for representing probabilities and performance data.

     ----------------------------------------------------------------------

List variables

   Lists are specified using curly brackets {} that enclose a comma-separated
   list of values.

  slist

   Description: A list of scalar strings

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

     vars:

      "xxx"    slist  => {  "literal1",  "literal2" };
      "yyy"    slist  => {
                         readstringlist(
                                       "/home/mark/tmp/testlist",
                                       "#[a-zA-Z0-9 ]*",
                                       "[^a-zA-Z0-9]",
                                       15,
                                       4000
                                       )
                         };

      "zzz"    slist  => { readstringlist("/home/mark/tmp/testlist2","#[^\n]*",",",5,4000) };

   Notes:

   Some functions return slists, and an slist may contain the values copied
   from another slist, rlist, or ilist. See policy.

  ilist

   Description: A list of integers

   Type: ilist

   Allowed input range: -99999999999,9999999999

   Example:

     vars:

       "variable_id"

            ilist => { "10", "11", "12" };

   Notes:

   Integer lists are lists of strings that are expected to be treated as
   integers. The typing in CFEngine is dynamic, so the variable types are
   interchangeable, but when you declare a variable to be type ilist,
   CFEngine verifies that each value you assign to it looks like an integer
   (e.g., 3, -17, 16K).

   Some functions return ilists, and an ilist may contain the values copied
   from another slist, rlist, or ilist. See policy

  rlist

   Description: A list of real numbers

   Type: rlist

   Allowed input range: -9.99999E100,9.99999E100

   Example:

     vars:

       "varid" rlist => { "0.1", "0.2", "0.3" };

   Notes:

   Real lists are lists of strings that are expected to be used as real
   numbers. The typing in CFEngine is dynamic, so the variable types are
   interchangeable, but when you declare a variable to be type rlist,
   CFEngine verifies that each value you assign to it looks like a real
   number (e.g., 3, 3.1415, .17, 6.02e23, -9.21e-17).

   Some functions return rlists, and an rlist may contain the values copied
   from another slist, rlist, or ilist. See policy

     ----------------------------------------------------------------------

Attributes

  policy

   Description: The policy for (dis)allowing (re)definition of variables

   Variables can either be allowed to change their value dynamically (be
   redefined) or they can be constant.

   Type: (menu option)

   Allowed input range:

     free
     overridable
     constant
     ifdefined

   Default value:

   policy = constant

   Example:

     vars:

       "varid" string => "value...",
               policy => "constant";

   Notes:

   The policy constant indicates that the variable value may not be changed.
   The policies free and overridable are synonymous, and indicated that the
   variable's value may be changed.

   The policy ifdefined applies only to lists and implies that unexpanded or
   undefined lists are dropped. The default behavior is otherwise to retain
   this value as an indicator of the failure to quench the variable
   reference, for example:

     "one" slist => { "1", "2", "3" };

     "list" slist => { "@(one)", @(two) },
           policy => "ifdefined";

   This results in @(list) being the same as @(one), and the reference to
   @(two) disappears. This is useful for combining lists.

   -^
*cf3-databases*

   CFEngine can interact with commonly used database servers to keep promises
   about the structure and content of data within them.

   There are two main cases of database management to address: small embedded
   databases and large centralized databases.

   Databases are often centralized entities that have a single point of
   management. While large monolithic database can be more easily managed
   with other tools, CFEngine can still monitor changes and discrepancies. In
   addition, CFEngine can also manage smaller embedded databases that are
   distributed in nature, whether they are SQL, registry or future types.

   For example, creating 100 new databases for test purposes is a task for
   CFEngine; but adding a new item to an important production database is not
   a recommended task for CFEngine.

   There are three kinds of database supported by CFEngine:

     * LDAP - The Lightweight Directory Access Protocol

   A hierarchical network database primarily for reading simple schema.

     * SQL - Structured Query Language

   A number of relational databases (currently supported: MySQL, Postgres)
   for reading and writing complex data.

     * Registry - Microsoft Registry

   An embedded database for interfacing with system values in Microsoft
   Windows (Only CFEngine Enterprise)

   In addition, CFEngine uses a variety of embedded databases for its own
   internals.

   Embedded databases are directly part of the system and promises can be
   made directly. However, databases running through a server process (either
   on the same host or on a different host) are independent agents and
   CFEngine cannot make promises on their behalf, unless they promise (grant)
   permission for CFEngine to make the changes. Thus the pre-requisite for
   making SQL database promises is to grant a point of access on the server.

     databases:

     "database/subkey or table"

        database_operation => "create/delete/drop",
        database_type => "sql/ms_registry",
        database_columns => {
                            "name,type,size",
                            "name,type",
                            },

        database_server => body;

     body database_server name
     {
       db_server_owner = "account name";
       db_server_password = "password";
       db_server_host = "hostname or omit for localhost";
       db_server_type = "mysql/posgres";
       db_server_connection_db = "database we can connect to";
     }

     body common control
     {
     bundlesequence => { "databases" };
     }

     bundle agent databases

     {
     #commands:

     #  "/usr/bin/createdb cf_topic_maps",

     #        contain => as_user("mysql");

     databases:

       "cf_topic_maps/topics"

         database_operation => "create",
         database_type => "sql",
         database_columns => {
                             "topic_name,varchar,256",
                             "topic_comment,varchar,1024",
                             "topic_id,varchar,256",
                             "topic_type,varchar,256",
                             "topic_extra,varchar,26"
                             },

         database_server => myserver;



     }

     ################################################

     body database_server myserver
     {
     any::
      db_server_owner => "postgres";
      db_server_password => "";
      db_server_host => "localhost";
      db_server_type => "postgres";
      db_server_connection_db => "postgres";
     none::
      db_server_owner => "root";
      db_server_password => "";
      db_server_host => "localhost";
      db_server_type => "mysql";
      db_server_connection_db => "mysql";
     }

     body contain as_user(x)
     {
     exec_owner => "$(x)";
     }

   The promiser in database promises is a concatenation of the database name
   and underlying tables. This presents a simple hierarchical model that
   looks like a file-system. This is the normal structure within the Windows
   registry for instance. Entity-relation databases do not normally present
   tables in this way, but no harm is done in representing them as a
   hierarchy of depth 1.

     ----------------------------------------------------------------------

Attributes

  database_server

   Type: body database_server

    db_server_owner

   Description: The db_server_owner string represents the user name for a
   database connection.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      db_server_owner => "mark";

    db_server_password

   Description: The db_server_password string represents the clear text
   password for a database connection.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      db_server_password => "xyz.1234";

    db_server_host

   Description: The db_server_host string represents the hostname or address
   for a database connection.

   A blank value is equal to localhost.

   Type: string

   Allowed input range: (arbitrary string)

   Example: cf3 db_server_host => "sqlserv.example.org";

    db_server_type

   Description: The db_server_type string represents the type of database
   server being used.

   Type: (menu option)

   Allowed input range:

     postgres
     mysql

   Default value: none

   Example:

      db_server_type => "postgres";

    db_server_connection_db

   Description: The db_server_connection_db string is the name of an existing
   database to connect to in order to create/manage other databases.

   In order to create a database on a database server (all of which practice
   voluntary cooperation), one has to be able to connect to the server.
   However, without an existing database this is not allowed. Thus, database
   servers provide a default database that can be connected to in order to
   thereafter create new databases. These are called postgres and mysql for
   their respective database servers.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body database_server myserver(x)
      {
      db_server_owner => "$(x)";
      db_server_password => "";
      db_server_host => "localhost";
      db_server_type => "$(mysql)";
      db_server_connection_db => "$(x)";
      }

   where x is currently mysql or postgres.

  database_type

   Description: The database_type menu option is a type of database that is
   to be manipulated.

   Type: (menu option)

   Allowed input range:

     sql
     ms_registry

   Default value: none

   Example:

 database_type => "ms_registry";

  database_operation

   Description: The database_operation menu option represents the nature of
   the promise.

   Type: (menu option)

   Allowed input range:

     create
     delete
     drop
     cache
     verify
     restore

   Example:

 database_operation => "create";

  database_columns

   Description: A database_columns slist defines column definitions to be
   promised by SQL databases.

   Columns are a list of tuplets (Name,type,size). Array items are triplets,
   and fixed size data elements are doublets.

   Type: slist

   Allowed input range: .*

   Example:

   "cf_topic_maps/topics"

     database_operation => "create",
     database_type => "sql",
     database_columns => {
                         "topic_name,varchar,256",
                         "topic_comment,varchar,1024",
                         "topic_id,varchar,256",
                         "topic_type,varchar,256",
                         "topic_extra,varchar,26"
                         },

     database_server => myserver;

  database_rows

   Description: database_rows is an ordered list of row values to be promised
   by SQL databases.

   This constraint is used only in adding data to database columns. Rows are
   considered to be instances of individual columns.

   Type: slist

   Allowed input range: .*,.*

   Example:

 bundle agent databases
 {
 databases:

  windows::

   # Regsitry has (value,data) pairs in "keys" which are directories

   "HKEY_LOCAL_MACHINE\SOFTWARE\CFEngine AS\CFEngine"

     database_operation => "create",
     database_rows => { "value1,REG_SZ,new value 1", "value2,REG_DWORD,12345"} ,
     database_type     => "ms_registry";
 }

   Notes:

   In the case of the system registry on Windows, the rows represent data on
   data-value pairs. The currently supported types (the middle field) for the
   Windows registry are REG_SZ (string), REG_EXPAND_SZ (expandable string)
   and REG_DWORD (double word).

  registry_exclude

   Description: An registry_exclude slist contains regular expressions to
   ignore in key/value verification.

   During recursive Windows registry scanning, this option allows us to
   ignore keys of values matching a list of regular expressions. Some values
   in the registry are ephemeral and some should not be considered. This
   provides a convenient way of avoiding names. It is analogous to
   exclude_dirs for files.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

 databases:

  "HKEY_LOCAL_MACHINE\SOFTWARE"

     database_operation => "cache",

     registry_exclude => { ".*Windows.*CurrentVersion.*",
                           ".*Touchpad.*",
                           ".*Capabilities.FileAssociations.*",
                           ".*Rfc1766.*" ,
                           ".*Synaptics.SynTP.*",
                           ".*SupportedDevices.*8086",
                           ".*Microsoft.*ErrorThresholds"
                         },

     database_type     => "ms_registry";

   -^
*cf3-files*

   Files promises are an umbrella for attributes of files. Operations fall
   basically into three categories: create, delete and edit.

     files:

       "/path/file_object"

           perms = perms_body,
           ... ;

   Prior to version 3, file promises were scattered into many different
   types, including files, tidy, copy, and links. File handling in CFEngine 3
   uses regular expressions everywhere for pattern matching. The old
   'wildcard/globbing' expressions \* and ? are deprecated, and everything is
   based consistently on Perl Compatible Regular Expressions.

   There is a natural ordering in file processing that obviates the need for
   the actionsequence. For example, the trick of using multiple
   actionsequence items with different classes.

     actionsequence = ( ... files.one  ..  files.two )

   can now be handled more elegantly using bundles. The natural ordering uses
   that fact that some operations are mutually exclusive and that some
   operations do not make sense in reverse order. For example, editing a file
   and then copying onto it would be nonsense. Similarly, you cannot both
   remove a file and rename it.

  File copying

   Copying is 'backwards'. Instead of the default object being source and the
   option being the destination, in CFEngine 3 the destination is paramount
   and the source is an option. This is because the model of voluntary
   cooperation tells us that it is the object that is changed, which is the
   agent making the promise. One cannot force change onto a destination with
   CFEngine, one can only invite change from a source.

  Normal ordering of promise attributes

   CFEngine has no 'action sequence'. Ordering of operations has, in most
   cases, a natural ordering that is assumed by the agent. For example,
   'delete then create' (normal ordering) makes sense, but 'create then
   delete' does not. This sort of principle can be extended to deal with all
   aspects of file promises.

   The diagram below shows the ordering. Notice that the same ordering
   applies regardless of file type (plain-file or directory). Note also that
   file editing is done "atomically".

   The normal ordering of file operators in CFEngine 3

   The pseudo-code for this logic is shown in the diagram and below:

  for each file promise-object
     {
     if (depth_search)
       do
         DepthSearch (HandleLeaf)
       else
         (HandleLeaf)
       done
     }

  HandleLeaf()
    {
    Does leaf-file exist?

      NO:  create
      YES: rename,delete,touch,

      do
       for all servers in {localhost, @(servers)}
          {
          if (server-will-provide)
             do
               if (depth_search)
                  embedded source-depth-search (use file source)
                  break
               else
                  (use file source)
                  break
               done
             done
          }
      done

    Do all links (always local)

    Check Permissions

    Do edits
    }

  Depth searches (aka 'recursion') during searches

   Recursion is called "depth-search", and CFEngine uses the 'globbing'
   symbols with standard regular expressions:

 /one/.*/two/thr.*/four

   When searching for hidden files (files with names starting with a '.') or
   files with specific extensions, you should take care to escape the dot
   (e.g., \.cshrc or .*\.txt) when you wish it to mean a literal character
   and not the any character interpretation provided by regular expression
   interpretation.

   When doing a recursive search, the files '.' and '..' are never included
   in the matched files, even if the regular expression in the leaf_name
   specifically allows them.

   The filename /dir/ect/ory/. is a special case used with the create
   attribute to indicate the directory named /dir/ect/ory and not any of the
   files under it. If you really want to specify a regular expression that
   matches any single-character filename, use /dir/ect/ory/[\w\W] as your
   promise regular expression (you can't use /dir/ect/ory[^/], see below for
   an explanation.

   Depth search refers to a search for file objects that starts from the one
   or more matched base-paths as shown in the example above.

  Filenames and regular expressions

   CFEngine allows regular expressions within filenames, but only after first
   doing some sanity checking to prevent some readily avoidable problems. The
   biggest rule you need to know about filenames and regular expressions is
   that all regular expressions in filenames are bounded by directory
   separators, and that each component expression is anchored between the
   directory separators. In other words, CFEngine splits up any file paths
   into its component parts, and then it evaluates any regular expressions at
   a component-level.

   What this means is that the path /tmp/gar.* will only match filenames like
   /tmp/gar, /tmp/garbage and /tmp/garden. It will not match filename like
   /tmp/gar/baz; because even though the .* in a regular expression means
   "zero or more of any character", CFEngine restricts that to mean "zero or
   more of any character in a path component".

   Correspondingly, CFEngine also restricts where you can use the /
   character. For example, you cannot use it in a character class like [^/]
   or in a parenthesized or repeated regular expression component.

   This means that regular expressions that include "optional directory
   components" will not work. You cannot have a files promise to tidy the
   directory (/usr)?/tmp. Instead, you need to be more verbose and specify
   /usr/tmp|/tmp. Potentially more efficient would be a declarative approach.
   First, create an slist that contains both the strings /tmp and /usr/tmp
   and then allow CFEngine to iterate over the list.

   This also means that the path /tmp/.*/something will match files such as
   /tmp/abc/something or /tmp/xyzzy/something. However, even though the
   pattern .* means "zero or more of any character (except /)", CFEngine
   matches files bounded by directory separators. So even though the pathname
   /tmp//something is technically the same as the pathname /tmp/something,
   the regular expression /tmp/.*/something will not match on the case of
   /tmp//something (or /tmp/something).

  Promises involving regular expressions

   CFEngine can only keep (or repair, or fail to keep) a promise on files
   which actually exist. If you make a promise based on a wildcard match,
   then the promise is only ever attempted if the match succeeds. However, if
   you make a promise containing a recursive search that includes a wildcard
   match, then the promise can be kept or repaired, provided that the
   directory specified in the promise exists. Consider the following two
   examples, which assume that there first exist files named /tmp/gar,
   /tmp/garbage and /tmp/garden. Initially, the two promises look like they
   should do the same thing; but there is a subtle difference:

                                     bundle agent foobaz                 
                                     {                                   
*cf3-files*:                            
                                         "/tmp"                          
   bundle agent foobaz                     delete => tidy,               
   {                                       depth_search => recurse("0"), 
   files:                                  file_select => gars,          
    "/tmp/gar.*"                           classes => if_ok("done");     
       delete => tidy,               }                                   
       classes => if_ok("done");                                         
   }                                 body file_select gars               
                                     {                                   
   body classes if_ok(x)             leaf_name => { "gar.*" };           
   {                                 file_result => "leaf_name";         
     promise_repaired => { "$(x)" }; }                                   
     promise_kept => { "$(x)" };                                         
   }                                 body classes if_ok(x)               
                                     {                                   
                                       promise_repaired => { "$(x)" };   
                                       promise_kept => { "$(x)" };       
                                     }                                   

   In the first example, when the configuration containing this promise is
   first executed, any file starting with "gar" that exists in the /tmp
   directory will be removed, and the done class will be set. However, when
   the configuration is executed a second time, the pattern /tmp/gar.* will
   not match any files, and that promise will not even be attempted (and,
   consequently the done class will not be set).

   In the second example, when the configuration containing this promise is
   first executed, any file starting with "gar" that exists in the /tmp
   directory will also be removed, and the done class will also be set. The
   second time the configuration is executed, however, the promise on the
   /tmp directory will still be executed (because /tmp of course still
   exists), and the done class will be set, because all files matching the
   file_select attribute have been deleted from that directory.

  Local and remote searches

   There are two distinct kinds of depth search:

     * A local search over promiser agents.
     * A remote search over provider agents.

   When we are copying or linking to a file source, it is the search over the
   remote source that drives the content of a promise (the promise is a
   promise to use what the remote source provides). In general, the sources
   are on a different device to the images that make the promises. For all
   other promises, we search over existing local objects.

   If we specify depth search together with copy of a directory, then the
   implied remote source search is assumed, and it is made after the search
   over local base-path objects has been made. If you mix complex promise
   body operations in a single promise, this could lead to confusion about
   the resulting behavior, and a warning is issued. In general it is not
   recommended to mix searches without a full understanding of the
   consequences, but this might occasionally be useful.

   Depth search is not allowed with edit_line promises.

     ----------------------------------------------------------------------

Attributes

  acl

   Type: body acl

    aces

   Description: Native settings for access control entry are defined by
   'aces'. POSIX ACL are available in CFEngine Community starting with 3.4.0.
   NTFS ACL are available in with CFEngine Enterprise.

   Type: slist

   Allowed input range:
   ((user|group):[^:]+:[-=+,rwx()dtTabBpcoD]*(:(allow|deny))?)|((all|mask):[-=+,rwx()]*(:(allow|deny))?)

   Form of the permissions is as follows:

                 aces = {
                         "user:uid:mode[:perm_type]", ...,
                         "group:gid:mode[:perm_type]", ...,
                         "all:mode[:perm_type]"
                         };

     * user

   indicates that the line applies to a user specified by the user identifier
   uid. mode is the permission mode string.

     * group

   Indicates that the line applies to a group specified by the group
   identifier gid. mode The permission mode string.

     * all

   Indicates that the line applies to every user. mode is the permission mode
   string.

     * uid

   A valid user identifier for the system and cannot be empty. However, uid
   can be set to * as a synonym for the entity that owns the file system
   object (e.g. user:*:r).

     * gid

   A valid group identifier for the system and cannot be empty. However, in
   some ACL types, gid can be set to * to indicate a special group (e.g. in
   POSIX this refers to the file group).

     * mode

   One or more strings op|perms|(nperms); a concatenation of op, perms and
   optionally (nperms) separated with commas (e.g. +rx,-w(s) ). mode is
   parsed from left to right.

     * op

   Specifies the operation on any existing permissions, if the defined ACE
   already exists. op can be =, empty, + or -. = or empty sets the
   permissions to the ACE as stated. + adds and - removes the permissions
   from any existing ACE.

     * nperms (optional)

   Specifies file system specific (native) permissions. Only valid if
   acl_type is defined. nperms will only be enforced if the file object is
   stored on a file system supporting the ACL type set in acl_type. For
   example, nperms will be ignored if acl_type:ntfs and the object is stored
   on a file system not supporting NTFS ACLs. Valid values for nperms varies
   with different ACL types, and is defined in subsequent sections.

     * perm_type (optional)

   Can be set to either allow or deny, and defaults to allow. deny is only
   valid if acl_type is set to an ACL type that support deny permissions. A
   deny ACE will only be enforced if the file object is stored on a file
   system supporting the acl type set in acl_type.

     * gperms (generic permissions)

   A concatenation of zero or more of the characters shown in the table
   below. If left empty, none of the permissions are set.

   Flag Description Semantics on file       Semantics on directory            
    r   Read        Read data, permissions, Read directory contents,          
                    attributes              permissions, attributes           
    w   Write       Write data              Create, delete, rename subobjects 
    x   Execute     Execute file            Access subobjects                 

   Note that the r permission is not necessary to read an object's
   permissions and attributes in all file systems. For example, in POSIX,
   having x on its containing directory is sufficient.

   Example:

      body acl template

      {
      acl_method => "overwrite";
      acl_type => "posix";
      acl_default => "access";

      aces => {
              "user:*:r(wwx),-r:allow",
              "group:*:+rw:allow",
              "mask:x:allow",
              "all:r"
              };
      }

    acl_default

   Description: The access control list type for the affected file system is
   determined by acl_default.

   Directories have ACLs associated with them, but they also have the ability
   to inherit an ACL to sub-objects created within them. POSIX calls the
   former ACL type "access ACL" and the latter "default ACL", and we will use
   the same terminology.

   The constraint acl_default gives control over the default ACL of
   directories. The default ACL can be left unchanged (nochange), empty
   (clear), or be explicitly specified (specify). In addition, the default
   ACL can be set equal to the directory's access ACL (access). This has the
   effect that child objects of the directory gets the same access ACL as the
   directory.

   Type: (menu option)

   Allowed input range:

     nochange
     access
     specify
     clear

   Example:

      body acl template

      {
      acl_method => "overwrite";
      acl_type => "posix";
      acl_default => "access";

      aces => {
              "user:*:rwx:allow",
              "group:*:+rw:allow",
              "mask:rx:allow",
              "all:r"
              };
      }

   History: Was introduced in 3.5. Replaces the now deprecated
   acl_directory_inherit.

    acl_method

   Description: The acl_method menu option defines the editing method for an
   access control list.

   When defining an ACL, we can either use an existing ACL as the starting
   point, or state all entries of the ACL. If we just care about one entry,
   say that the superuser has full access, the method constraint can be set
   to append, which is the default. This has the effect that all the existing
   ACL entries that are not mentioned will be left unchanged. On the other
   hand, if method is set to overwrite, the resulting ACL will only contain
   the mentioned entries. When doing this, it is important to check that all
   the required ACL entries are set. For example, owning user, group and all
   in POSIX ACLs.

   Type: (menu option)

   Allowed input range:

     append
     overwrite

   Example:

      body acl template

      {
      acl_method => "overwrite";
      acl_type => "posix";
      aces => { "user:*:rw:allow", "group:*:+r:allow", "all:"};
      }

    acl_type

   Description: The acl_type menu option defines the access control list type
   for the affected file system.

   ACLs are supported on multiple platforms, which may have different sets of
   available permission flags. By using the constraint acl_type, we can
   specify which platform, or ACL API, we are targeting with the ACL.

   The default, generic, is designed to work on all supported platforms.
   However, if very specific permission flags are required, like Take
   Ownership on the NTFS platform, we must set acl_type to indicate the
   target platform. Currently, the supported values are posix and ntfs.

   Type: (menu option)

   Allowed input range:

     generic
     posix
     ntfs

   Example:

      body acl template

      {
      acl_type => "ntfs";
      aces => { "user:Administrator:rwx(po)", "user:Auditor:r(o)"};
      }

    specify_default_aces

   Description: The slist specify_default_aces specifies the native settings
   for access control entry.

   specify_default_aces (optional) is a list of access control entries that
   are set on child objects. It is also parsed from left to right and allows
   multiple entries with same entity-type and id. Only valid if acl_default
   is set to specify.

   This is an ACL which makes explicit setting for the acl inherited by new
   objects within a directory. It is included for those implementations that
   do not have a clear inheritance policy.

   Type: slist

   Allowed input range:
   ((user|group):[^:]+:[-=+,rwx()dtTabBpcoD]*(:(allow|deny))?)|((all|mask):[-=+,rwx()]*(:(allow|deny))?)

   Example:

      body acl template
      {
      specify_default_aces => {  "all:r" };
      }

  changes

   Type: body changes

    hash

   Description: The hash menu option defines the ash files for change
   detection.

   The best option cross correlates the best two available algorithms known
   in the OpenSSL library.

   Type: (menu option)

   Allowed input range:

     md5
     sha1
     sha224
     sha256
     sha384
     sha512
     best

   Example:

      body changes example
      {
      hash => "md5";
      }

    report_changes

   Description: Specify criteria for change warnings using the report_changes
   menu option.

   Files can change in permissions and contents, i.e. external or internal
   attributes. If all is chosen all attributes are checked.

   Type: (menu option)

   Allowed input range:

     all
     stats
     content
     none

   Example:

      body changes example
      {
      report_changes => "content";
      }

    update_hashes

   Description: Use of update_hashes determines whether hash values should be
   updated immediately after a change.

   If this is positive, file hashes should be updated as soon as a change is
   registered so that multiple warnings are not given about a single change.
   This applies to addition and removal too.

   Type: boolean

   Example:

      body changes example
      {
      update_hashes => "true";
      }

    report_diffs

   This feature requires CFEngine Enterprise.

   Description: Setting report_diffs determines whether to generate reports
   summarizing the major differences between individual text files.

   If true, CFEngine will log a 'diff' summary of major changes to the files.
   It is not permitted to combine this promise with a depth search, since
   this would consume a dangerous amount of resources and would lead to
   unreadable reports.

   The feature is intended as a informational summary, not as a version
   control function suitable for transaction control. If you want to do
   versioning on system files, you should keep a single repository for them
   and use CFEngine to synchronize changes from the repository source.
   Repositories should not be used to attempt to capture random changes of
   the system.

   Type: boolean

   Example:

      body changes example
      {
      report_diffs => "true";
      }

  copy_from

   Type: body copy_from

    source

   Description: The source string represents the reference source file from
   which to copy. For remote copies this refers to the file name on the
   remote server.

   Type: string

   Allowed input range: .+

   Example:

      body copy_from example
      {
      source => "/path/to/source";
      }

    servers

   Description: The servers slist names servers in order of preference from
   which to copy. The servers are tried in order until one of them succeeds.

   Type: slist

   Allowed input range: [A-Za-z0-9_.:-]+

   Example:

      body copy_from example
      {
      servers => { "primary.example.org", "secondary.example.org",
                       "tertiary.other.domain" };
      }

    collapse_destination_dir

   Description: The collapse_destination_dir menu option supports the placing
   of files in subdirectories into the root destination directory during
   copy.

   Under normal operations, recursive copies cause CFEngine to track
   subdirectories of files. So, for instance, if we copy recursively from src
   to dest, then src/subdir/file will map to dest/subdir/file.

   By setting this option to true, the promiser destination directory
   promises to aggregate files searched from all subdirectories into itself;
   in other words, a single destination directory.

   Type: boolean

   Example:

      body copy_from mycopy(from,server)
      {
      source      => "$(from)";
      servers     => { "$(server)" };
      collapse_destination_dir => "true";
      }

    compare

   Description: The menu option policy compare is used for comparing source
   and image file attributes.

   The default copy method is mtime (modification time), meaning that the
   source file is copied to the destination (promiser) file, if the source
   file has been modified more recently than the destination.

   Type: (menu option)

   Allowed input range:

     * mtime

   CFEngine copies the file if the modification time of the source file is
   more recent than that of the promised file

     * ctime

   CFEngine copies the file if the creation time of the source file is more
   recent than that of the promised file

     * atime

   CFEngine copies the file if the modification time or creation time of the
   source file is more recent than that of the promised file. If the times
   are equal, a byte-for-bye comparison is done on the files to determine if
   it needs to be copied.

     * exists

   CFEngine copies the file if the promised file does not already exist.

     * binary

   CFEngine copies the file if they are both plain files and a byte-for-byte
   comparison determines that they are different. If both are not plain
   files, CFEngine reverts to comparing the mtime and ctime of the files. If
   the source file is on a different machine (e.g. network copy), then hash
   is used instead to reduce network bandwidth.

     * hash

   CFEngine copies the file if they are both plain files and a message digest
   comparison indicates that the files are different. In Enterprise versions
   of CFEngine version 3.1.0 and later, SHA256 is used as a message digest
   hash to conform with FIPS; in older Enterprise versions of CFEngine and
   all Community versions, MD5 is used.

     * digest a synonym for hash

   Default value: mtime or ctime differs

   Example:

      body copy_from example
      {
      compare => "digest";
      }

    copy_backup

   Description: Menu option policy for file backup/version control

   Determines whether a backup of the previous version is kept on the system.
   This should be viewed in connection with the system repository, since a
   defined repository affects the location at which the backup is stored.

   Type: (menu option)

   Allowed input range:

     true
     false
     timestamp

   Default value: true

   Example:

      body copy_from example
      {
      copy_backup => "timestamp";
      }

    encrypt

   Description: The encrypt menu option policy describes whether to use
   encrypted data stream to connect to remote hosts.

   Client connections are encrypted with using a Blowfish randomly generated
   session key. The initial connection is encrypted using the public/private
   keys for the client and server hosts.

   Type: boolean

   Default value: false

   Example:

      body copy_from example
      {
      servers  => { "remote-host.example.org" };
      encrypt => "true";
      }

    check_root

   Description: The check_root menu option policy checks permissions on the
   root directory when copying files recursively by depth_search.

   This flag determines whether the permissions of the root directory should
   be set from the root of the source. The default is to check only copied
   file objects and subdirectories within this root (false).

   Type: boolean

   Example:

      body copy_from example
      {
      check_root => "true";
      }

    copylink_patterns

   Description: The copylink_patterns slist of patterns are matching files
   that should be copied instead of linked.

   The matches are performed on the last node of the filename; in other
   words, the file without its path. As Windows does not support symbolic
   links, this feature is not available there.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

      body copy_from example
      {
      copylink_patterns => { "special_node1", "other_node.*" };
      }

    copy_size

   Description: The integers specified in copy_size determines the range for
   the size of files that may be copied.

   The use of the irange function is optional. Ranges may also be specified
   as comma separated numbers.

   Type: irange[int,int]

   Allowed input range: 0,inf

   Default value: any size range

   Example:

      body copy_from example
      {
      copy_size => irange("0","50000");
      }

    findertype

   Description: The findertype menu option policy describes the default
   finder type on MacOSX.

   This applies only to the Mac OS X variants.

   Type: (menu option)

   Allowed input range:

     MacOSX

   Example:

      body copy_from example
      {
      findertype => "MacOSX";
      }

    linkcopy_patterns

   Description: The linkcopy_patterns contains patterns for matching files
   that should be replaced with symbolic links.

   The pattern matches the last node filename; in other words, without the
   absolute path. Windows only supports hard links.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

      body copy_from mycopy(from)
      {
      source            => "$(from)";
      linkcopy_patterns => { ".*" };
      }

   See Also: link_type.

    link_type

   Description: The link_type menu option policy contains the type of links
   to use when copying.

   Users are advised to be wary of 'hard links' (see Unix manual pages for
   the ln command). The behavior of non-symbolic links is often precarious
   and unpredictable. However, hard links are the only supported type by
   Windows.

   Note that symlink is synonymous with absolute links, which are different
   from relative links. Although all of these are symbolic links, the
   nomenclature here is defined such that symlink and absolute are
   equivalent. When verifying a link, choosing 'relative' means that the link
   must be relative to the source, so relative and absolute links are
   mutually exclusive.

   Type: (menu option)

   Allowed input range:

     symlink
     hardlink
     relative
     absolute

   Default value: symlink

   Example:

      body link_from example
      {
      link_type => "symlink";
      source => "/tmp/source";
      }

    force_update

   Description: The force_update menu option policy instructs whether to
   always force copy update.

   Warning: this is a non-convergent operation. Although the end point might
   stabilize in content, the operation will never quiesce. Use of this
   feature is not recommended except in exceptional circumstances since it
   creates a busy-dependency. If the copy is a network copy, the system will
   be disturbed by network disruptions.

   Type: boolean

   Default value: false

   Example:

      body copy_from example
      {
      force_update => "true";
      }

    force_ipv4

   Description: The force_ipv4 menu option policy can determine whether to
   use ipv4 on an ipv6 enabled network.

   IPv6 should be harmless to most users unless you have a partially or
   mis-configured setup.

   Type: boolean

   Default value: false

   Example:

      body copy_from example
      {
      force_ipv4 => "true";
      }

    portnumber

   Description: Setting portnumber determines the port number to connect to
   on a server host.

   The standard or registered port number is tcp/5308. CFEngine does not
   presently use its registered udp port with the same number, but this could
   change in the future.

   Type: int

   Allowed input range: 1024,99999

   Example:

      body copy_from example
      {
      portnumber => "5308";
      }

    preserve

   Description: Setting the preserve menu option policy determines whether to
   preserve file permissions on copied files.

   This ensures that the destination file (promiser) gets the same file
   permissions as the source. For local copies, all attributes are preserved,
   including ACLs and SELinux security contexts. For remote copies, only Unix
   mode is preserved.

   Type: boolean

   Default value: false

   Example:

      body copy_from example
      {
      preserve => "true";
      }

   History: Version 3.1.0b3,Nova 2.0.0b1 (2010)

    purge

   Description: The purge menu option policy instructs on whether to purge
   files on client that do not match files on server when a depth_search is
   used.

   Purging files is a potentially dangerous matter during a file copy it
   implies that any promiser (destination) file which is not matched by a
   source will be deleted. Since there is no source, this means the file will
   be irretrievable. Great care should be exercised when using this feature.

   Note that purging will also delete backup files generated during the file
   copying if copy_backup is set to true.

   Type: boolean

   Default value: false

   Example:

      body copy_from example
      {
      purge => "true";
      }

    stealth

   Description: Setting the stealth menu option policy determines whether to
   preserve time stamps on copied files. This preserves file access and
   modification times on the promiser files.

   Type: boolean

   Default value: false

   Example:

      body copy_from example
      {
      stealth => "true";
      }

    timeout

   Description: The integer set in timeout is the value for the connection
   timeout, in seconds.

   Type: int

   Allowed input range: 1,3600

   Example:

      body runagent control
      {
      timeout => "10";
      }

    trustkey

   Description: The trustkey menu option policy determines whether to trust
   public keys from a remote server, if previously unknown.

   If the server's public key has not already been trusted, trustkey provides
   automated key-exchange.

   Note that, as a simple security precaution, trustkey should normally be
   set to false. Even though the risks to the client low, it is a good
   security practice to avoid key exchange with a server one is not one
   hundred percent sure about. On the server-side however, trust is often
   granted to many clients or to a whole network in which possibly
   unauthorized parties might be able to obtain an IP address. Thus the trust
   issue is most important on the server side.

   As soon as a public key has been exchanged, the trust option has no
   effect. A machine that has been trusted remains trusted until its key is
   manually revoked by a system administrator. Keys are stored in
   WORKDIR/ppkeys.

   Type: boolean

   Default value: false

   Example:

      body copy_from example
      {
      trustkey => "true";
      }

    type_check

   Description: The type_check menu option policy compares file types before
   copying.

   File types at source and destination should normally match in order for
   updates to overwrite them. This option allows this checking to be switched
   off.

   Type: boolean

   Example:

      body copy_from example
      {
      type_check => "false";
      }

    verify

   Description: The verify menu option policy instructs whether to verify
   transferred file by hashing after copy.

   Warning: This is a highly resource intensive option, and is not
   recommended for large file transfers.

   Type: boolean

   Default value: false

   Example:

      body copy_from example
      {
      verify => "true";
      }

  create

   Description: true/false whether to create non-existing file

   Directories are created by using the /. to signify a directory type. Note
   that, if no permissions are specified, mode 600 is chosen for a file, and
   mode 755 is chosen for a directory. If you cannot accept these defaults,
   you should specify permissions.

   Note that technically, /. is a regular expression. However, it is used as
   a special case meaning "directory". See filenames and regular expressions
   for a more complete discussion.

   Type: boolean

   Default value: false

   Example:

 files:

   "/path/plain_file"

      create =>   "true";

   "/path/dir/."

      create =>   "true";

   Note: In general, you should not use create with copy_from or link_from in
   files promises. These latter attributes automatically create the promised
   file, and using create may actually prevent the copy or link promise from
   being kept (since create acts first, which may affect file comparison or
   linking operations).

  delete

   Type: body delete

    dirlinks

   Description: Menu option policy for dealing with symbolic links to
   directories during deletion

   Links to directories are normally removed just like any other link or file
   objects. By keeping directory links, you preserve the logical directory
   structure of the file system, so that a link to a directory is not removed
   but is treated as a directory to be descended into.

   The value keep instructs CFEngine not to remove directory links. The
   values delete and tidy are synonymous, and instruct CFEngine to remove
   directory links.

   Type: (menu option)

   Allowed input range:

     delete
     tidy
     keep

   Example:

      body delete example
      {
      dirlinks => "keep";
      }

   Default value (only if body is present): dirlinks = delete

   The default value only has significance if there is a delete body present.
   If there is no delete body then files (and directory links) are not
   deleted.

    rmdirs

   Description: true/false whether to delete empty directories during
   recursive deletion

   Type: boolean

   Example:

      body delete example
      {
      rmdirs => "true";
      }

   Note the parent directory of a search is not deleted in recursive
   deletions. You must code a separate promise to delete the single parent
   object.

      bundle agent cleanup
      {
      files:

        # This will not delete the parent

        "/home/mark/tmp/testcopy"

          delete => tidyfiles,
          file_select => changed_within_1_year,
          depth_search => recurse("inf");

        # Now delete the parent.

        "/home/mark/tmp/testcopy"
          delete => tidyfiles;
      }

      body delete tidyfiles
      {
      dirlinks => "delete";
      rmdirs   => "true";
      }

      body file_select changed_within_1_year
      {
      mtime     => irange(ago(1,0,0,0,0,0),now);
      file_result => "mtime";
      }

   Default value (only if body is present): rmdirs = true

   The default value only has significance if there is a delete body present.
   If there is no delete body then files (and directories) are not deleted.

  depth_search

   Type: body depth_search

    depth

   Description: Maximum depth level for search

   When searching recursively from a directory, the parent directory is only
   the anchor point and is not part of the search. To alter the parent, a
   separate non-recursive promise should be made.

   Type: int

   Allowed input range: 0,99999999999

   Note that the value inf may be used for an unlimited value.

   Example:

      body depth_search example
      {
      depth => "inf";
      }

    exclude_dirs

   Description: List of regexes of directory names NOT to include in depth
   search

   Directory names are treated specially when searching recursively through a
   file system.

   Type: slist

   Allowed input range: .*

   Example:

      body depth_search
      {
      # no dot directories
      exclude_dirs => { "\..*" };
      }

    include_basedir

   Description: true/false include the start/root dir of the search results

   When checking files recursively (with depth_search) the promiser is a
   directory. This parameter determines whether that initial directory should
   be considered part of the promise or simply a boundary that marks the edge
   of the search. If true, the promiser directory will also promise the same
   attributes as the files inside it.

   Type: boolean

   Example:

      body depth_search example
      {
      include_basedir => "true";
      }

    include_dirs

   Description: List of regexes of directory names to include in depth search

   This is the complement of exclude_dirs.

   Type: slist

   Allowed input range: .*

   Example:

      body depth_search example
      {
      include_dirs => { "subdir1", "subdir2", "pattern.*" };
      }

    rmdeadlinks

   Description: true/false remove links that point to nowhere

   A value of true determines that links pointing to files that do not exist
   should be deleted; or kept if set to false.

   Type: boolean

   Default value: false

   Example:

      body depth_search example
      {
      rmdeadlinks => "true";
      }

    traverse_links

   Description: true/false traverse symbolic links to directories

   If this is true, cf-agent will treat symbolic links to directories as if
   they were directories. Normally this is considered a potentially dangerous
   assumption and links are not traversed.

   Type: boolean

   Default value: false

   Example:

      body depth_search example
      {
      traverse_links => "true";
      }

    xdev

   Description: true/false exclude directories that are on different devices

   Type: boolean

   Default value: false

   Example:

      body depth_search example
      {
      xdev => "true";
      }

  edit_defaults

   Type: body edit_defaults

    edit_backup

   Description: Menu option for backup policy on edit changes

   Type: (menu option)

   Allowed input range:

     true
     false
     timestamp
     rotate

   Default value: true

   Example:

      body edit_defaults example
      {
      edit_backup => "timestamp";
      }

    empty_file_before_editing

   Description: Baseline memory model of file to zero/empty before commencing
   promised edits.

   Emptying a file before reconstructing its contents according to a fixed
   recipe allows an ordered procedure to be convergent.

   Type: boolean

   Default value: false

   Example:

      body edit_defaults example
      {
      empty_file_before_editing => "true";
      }

    inherit

   Description: If true this causes the sub-bundle to inherit the private
   classes of its parent

   Type: boolean

   Example:

      bundle agent name
      {
      methods:

        "group name" usebundle => my_method,
                       inherit => "true";
      }

      body edit_defaults example
      {
      inherit => "true";
      }

   History: Was introduced in 3.4.0, Enterprise 3.0.0 (2012)

   Default value: false

   Notes: The inherit constraint can be added to the CFEngine code in two
   places: for edit_defaults and in methods promises. If set to true, it
   causes the child-bundle named in the promise to inherit only the classes
   of the parent bundle. Inheriting the variables is unnecessary as the child
   can always access the parent's variables by a qualified reference using
   its bundle name. For example, $(bundle.variable).

    max_file_size

   Description: Do not edit files bigger than this number of bytes

   max_file_size is a local, per-file sanity check to make sure the file
   editing is sensible. If this is set to zero, the check is disabled and any
   size may be edited. The default value of max_file_size is determined by
   the global control body setting whose default value is 100k.

   Type: int

   Allowed input range: 0,99999999999

   Example:

      body edit_defaults example
      {
      max_file_size => "50K";
      }

    recognize_join

   Description: Join together lines that end with a backslash, up to 4kB
   limit

   If set to true, this option allows CFEngine to process line based files
   with backslash continuation. The default is to not process continuation
   backslashes.

   Back slash lines will only be concatenated if the file requires editing,
   and will not be restored. Restoration of the backslashes is not possible
   in a meaningful and convergent fashion.

   Type: boolean

   Default value: false

   Example:

      files:

        "/tmp/test_insert"
                  create => "true",
               edit_line => Insert("$(insert.v)"),
           edit_defaults => join;
      }

      #

      body edit_defaults join
      {
      recognize_join => "true";
      }

    rotate

   Description: How many backups to store if 'rotate' edit_backup strategy is
   selected. Defaults to 1

   Used for log rotation. If the file is named foo and the rotate attribute
   is set to 4, as above, then initially foo is copied to foo.1 and the old
   file foo is zeroed out. In other words, the inode of the original logfile
   does not change, but the original logfile will be empty after the rotation
   is complete.

   The next time the promise is executed, foo.1 will be renamed foo.2, foo is
   again copied to foo.1 and the old file foo is again zeroed out.

   A promise may typically be executed as guarded by time-based or
   file-size-based classes. Each time the promise is executed the files are
   copied/zeroed or rotated (as above) until there are rotate numbered files,
   plus the one "main" file. In the example above, the file foo.3 will be
   renamed foo.4, but the old version of the file foo.4 will be deleted (that
   is, it "falls off the end" of the rotation).

   Type: int

   Allowed input range: 0,99

   Example:

      body rename example
      {
      rotate => "4";
      }

  edit_line

   Type: bundle edit_line

  edit_template

   Description: The name of a special CFEngine template file to expand

   The template format uses inline tags to mark regions and classes. Each
   line represents an insert_lines promise, unless the promises are grouped
   into a block using:

     [%CFEngine BEGIN %]
     ...
     [%CFEngine END %]

   Variables, scalars and list variables are expanded within each promise. If
   lines are grouped into a block, the whole block is repeated when lists are
   expanded (see the Special Topics Guide on editing).

   If a class-context modified is used:

 [%CFEngine class-expression:: %]

   then the lines that follow are only inserted if the context matches the
   agent's current context. This allows conditional insertion.

   Type: string

   Allowed input range: "?(/.*)

   Example:

     #This is a template file /templates/input.tmpl

     These lines apply to anyone

     [%CFEngine solaris.Monday:: %]
     Everything after here applies only to solaris on Mondays
     until overridden...

     [%CFEngine linux:: %]
     Everything after here now applies now to linux only.

     [%CFEngine BEGIN %]
     This is a block of text
     That contains list variables: $(some.list)
     With text before and after.
     [%CFEngine END %]

     nameserver $(some.list)

   For example:

     [%CFEngine any:: %]
     VirtualHost $(sys.ipv4[eth0]):80>
             ServerAdmin             $(stage_file.params[apache_mail_address][1])
             DocumentRoot            /var/www/htdocs
             ServerName              $(stage_file.params[apache_server_name][1])
             AddHandler              cgi-script cgi
             ErrorLog                /var/log/httpd/error.log
             AddType                 application/x-x509-ca-cert .crt
             AddType                 application/x-pkcs7-crl    .crl
             SSLEngine               off
             CustomLog               /var/log/httpd/access.log
     /VirtualHost>

     [%CFEngine webservers_prod:: %]
     [%CFEngine BEGIN %]
     VirtualHost $(sys.ipv4[$(bundle.interfaces)]):443>                                              
             ServerAdmin             $(stage_file.params[apache_mail_address][1])
             DocumentRoot            /var/www/htdocs                                 
             ServerName              $(stage_file.params[apache_server_name][1])           
             AddHandler              cgi-script cgi                                
             ErrorLog                /var/log/httpd/error.log                 
             AddType                 application/x-x509-ca-cert .crt               
             AddType                 application/x-pkcs7-crl    .crl               
             SSLEngine               on                                            
             SSLCertificateFile      $(stage_file.params[apache_ssl_crt][1])
             SSLCertificateKeyFile   $(stage_file.params[apache_ssl_key][1])
             CustomLog               /var/log/httpd/access.log                     
     /VirtualHost>
     [%CFEngine END %]

   History: Was introduced in 3.3.0, Nova 2.2.0 (2012)

  edit_xml

   Type: bundle edit_xml

  file_select

   Type: body file_select

    leaf_name

   Description: List of regexes that match an acceptable name

   This pattern matches only the node name of the file, not its path.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

      body file_select example
      {
      leaf_name => { "S[0-9]+[a-zA-Z]+", "K[0-9]+[a-zA-Z]+" };
      file_result => "leaf_name";
      }

    path_name

   Description: List of pathnames to match acceptable target

   Path name and leaf name can be conveniently tested for separately by use
   of appropriate regular expressions.

   Type: slist

   Allowed input range: "?(/.*)

   Example:

      body file_select example
      {
      leaf_name => { "prog.pid", "prog.log" };
      path_name => { "/etc/.*", "/var/run/.*" };

      file_result => "leaf_name.path_name"
      }

    search_mode

   Description: A list of mode masks for acceptable file permissions

   The mode may be specified in symbolic or numerical form with + and -
   constraints. Concatenation ug+s implies u OR g, and u+s,g+s implies u AND
   g.

   Type: slist

   Allowed input range: [0-7augorwxst,+-]+

   Example:

      bundle agent testbundle
      {
      files:

        "/home/mark/tmp/testcopy"

          file_select => by_modes,
          transformer => "/bin/echo DETECTED $(this.promiser)",
          depth_search => recurse("inf");

      }

      body file_select by_modes
      {
      search_mode => { "711" , "666" };
      file_result => "mode";
      }

      body depth_search recurse(d)
      {
      depth => "$(d)";
      }

    search_size

   Type: irange[int,int]

   Allowed input range: 0,inf

   Description: Integer range of file sizes

   Example:

      body file_select example
      {
      search_size => irange("0","20k");
      file_result => "size";
      }

    search_owners

   Description: List of acceptable user names or ids for the file, or regexes
   to match

   A list of anchored regular expressions any of which must match the entire
   userid.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

      body file_select example
      {
      search_owners => { "mark", "jeang", "student_.*" };
      file_result => "owner";
      }

   Notes: Windows does not have user ids, only names.

    search_groups

   Description: List of acceptable group names or ids for the file, or
   regexes to match

   A list of anchored regular expressions, any of which must match the entire
   group.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

      body file_select example
      {
      search_groups => { "users", "special_.*" };
      file_result => "group";
      }

   Notes: On Windows, files do not have group associations.

    search_bsdflags

   Description: String of flags for bsd file system flags expected set

   Extra BSD file system flags (these have no effect on non-BSD versions of
   CFEngine). See the manual page for chflags for more details.

   Type: slist

   Allowed input range:
   [+-]*[(arch|archived|nodump|opaque|sappnd|sappend|schg|schange|simmutable|sunlnk|sunlink|uappnd|uappend|uchg|uchange|uimmutable|uunlnk|uunlink)]+

   Example:

      body file_select xyz
      {
      search_bsdflags => "archived|dump";
      file_result => "bsdflags";
      }

    ctime

   Description: Range of change times (ctime) for acceptable files

   The file's change time refers to both modification of content and
   attributes, such as permissions. On Windows, ctime refers to creation
   time.

   Type: irange[int,int]

   Allowed input range: 0,2147483647

   Example:

      body files_select example
      {
      ctime => irange(ago(1,0,0,0,0,0),now);
      file_result => "ctime";
      }

    mtime

   Description: Range of modification times (mtime) for acceptable files

   The file's modification time refers to both modification of content but
   not other attributes, such as permissions.

   Type: irange[int,int]

   Allowed input range: 0,2147483647

   Example:

      body files_select example
      {
      # Files modified more than one year ago (i.e., not in mtime range)
      mtime => irange(ago(1,0,0,0,0,0),now);
      file_result => "!mtime";
      }

    atime

   Description: Range of access times (atime) for acceptable files

   A range of times during which a file was accessed can be specified in a
   file_select body.

   Type: irange[int,int]

   Allowed input range: 0,2147483647

   Example:

      body file_select used_recently
      {
      # files accessed within the last hour
      atime     => irange(ago(0,0,0,1,0,0),now);
      file_result => "atime";
      }


      body file_select not_used_much
      {
      # files not accessed since 00:00 1st Jan 2000 (in the local timezime)
      atime     => irange(on(2000,1,1,0,0,0),now);
      file_result => "!atime";
      }

    exec_regex

   Description: Matches file if this regular expression matches any full line
   returned by the command

   The regular expression must be used in conjunction with the exec_program
   test. In this way the program must both return exit status 0 and its
   output must match the regular expression. The entire output must be
   matched.

   Type: string

   Allowed input range: .*

   Example:

      body file_select example
      {
      exec_regex => "SPECIAL_LINE: .*";
      exec_program => "/path/test_program $(this.promiser)";
      file_result => "exec_program.exec_regex";
      }

    exec_program

   Description: Execute this command on each file and match if the exit
   status is zero

   This is part of the customizable file search criteria. If the user-defined
   program returns exit status 0, the file is considered matched.

   Type: string

   Allowed input range: "?(/.*)

   Example:

      body file_select example
      {
      exec_program => "/path/test_program $(this.promiser)";
      file_result => "exec_program";
      }

    file_types

   Description: List of acceptable file types from menu choices

   File types vary in details between operating systems. The main POSIX types
   are provided here as menu options, with reg being a synonym for plain. In
   both cases this means not one of the "special" file types.

   Type: (option list)

   Allowed input range:

     plain
     reg
     symlink
     dir
     socket
     fifo
     door
     char
     block

   Example:

      body file_select filter
      {
      file_types => { "plain","symlink" };

      file_result => "file_types";
      }

    issymlinkto

   Description: List of regular expressions to match file objects

   If the file is a symbolic link that points to files matched by one of
   these expressions, the file will be selected.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

      body file_select example
      {
      issymlinkto => { "/etc/[^/]*", "/etc/init\.d/[a-z0-9]*" };
      }

   Notes: Windows does not support symbolic links, so this attribute is not
   applicable on that platform.

    file_result

   Description: Logical expression combining classes defined by file search
   criteria

   The syntax is the same as for a class expression, since the file selection
   is a classification of the file-search in the same way that system classes
   are a classification of the abstract host-search. That is, you may specify
   a boolean expression involving any of the file-matching components.

   Type: string

   Allowed input range:
   [!*(leaf_name|path_name|file_types|mode|size|owner|group|atime|ctime|mtime|issymlinkto|exec_regex|exec_program|bsdflags)[|.]*]*

   Example:

      body file_select year_or_less
      {
      mtime       => irange(ago(1,0,0,0,0,0),now); 
      file_result => "mtime";
      }

      body file_select my_pdf_files_morethan1dayold
      {
      mtime         => irange(ago(0,0,1,0,0,0),now); 
      leaf_name     => { ".*\.pdf" , ".*\.fdf" };
      search_owners => { "mark" };

      file_result => "owner.leaf_name.!mtime";
      }

   You may specify arbitrarily complex file-matching parameters, such as what
   is shown above, "is owned by mark, has the extension '.pdf' or '.fdf', and
   whose modification time is not between 1 day ago and now"; that is, it is
   older than 1 day.

   See also: process_result

  link_from

   Type: body link_from

    copy_patterns

   Description: A set of patterns that should be copied and synchronized
   instead of linked

   During the linking of files, it is sometimes useful to buffer changes with
   an actual copy, especially if the link is to an ephemeral file system.
   This list of patterns matches files that arise during a linking policy. A
   positive match means that the file should be copied and updated by
   modification time.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

      body link_from example
      {
      copy_patterns =>  { "special_node1", "/path/special_node2" };
      }

    link_children

   Description: true/false whether to link all directory's children to source
   originals

   If the promiser is a directory, instead of copying the children, link them
   to the source.

   Type: boolean

   Default value: false

   Example:

      body link_from example
      {
      link_children => "true";
      }

    link_type

   Description: The type of link used to alias the file

   This determines what kind of link should be used to link files. Users are
   advised to be wary of 'hard links' (see Unix manual pages for the ln
   command). The behavior of non-symbolic links is often precarious and
   unpredictable.

   Note that symlink is synonymous with absolute links, which are different
   from relative links. Although all of these are symbolic links, the
   nomenclature here is defined such that symlink and absolute are equivalent
   . When verifying a link, choosing 'relative' means that the link must be
   relative to the source, so relative and absolute links are mutually
   exclusive.

   Type: (menu option)

   Allowed input range:

     symlink
     hardlink
     relative
     absolute

   Default value: symlink

   Example:

      body link_from example
      {
      link_type => "symlink";
      source => "/tmp/source";
      }

   Notes: On Windows, hard links are the only supported type.

    source

   Description: The source file to which the link should point

   For remote copies this refers to the file name on the remote server.

   Type: string

   Allowed input range: .+

   Example:

      body link_from example
      {
      source => "/path/to/source";
      }

    when_linking_children

   Description: Policy for overriding existing files when linking directories
   of children

   The options refer to what happens if the directory already exists, and is
   already partially populated with files. If the directory being copied from
   contains a file with the same name as that of a link to be created, it
   must be decided whether to override the existing destination object with a
   link, or simply omit the automatic linkage for files that already exist.
   The latter case can be used to make a copy of one directory with certain
   fields overridden.

   Type: (menu option)

   Allowed input range:

     override_file
     if_no_such_file

   Example:

      body link_from example
      {
      when_linking_children => "if_no_such_file";
      }

    when_no_source

   Description: Behavior when the source file to link to does not exist

   This describes how CFEngine should respond to an attempt to create a link
   to a file that does not exist. The options are to force the creation to a
   file that does not (yet) exist, delete any existing link, or do nothing.

   Type: (menu option)

   Allowed input range:

     force
     delete
     nop

   Default value: nop

   Example:

      body link_from example
      {
      when_no_source => "force";
      }

  move_obstructions

   Description: true/false whether to move obstructions to file-object
   creation

   If we have promised to make file X a link, but it already exists as a
   file, or vice-versa, or if a file is blocking the creation of a directory,
   then normally CFEngine will report an error. If this is set, existing
   objects will be moved aside to allow the system to heal without
   intervention. Files and directories are saved/renamed, but symbolic links
   are deleted.

   Note that symbolic links for directories are treated as directories, not
   links. This behavior can be discussed, but the aim is to err on the side
   of caution.

   Type: boolean

   Default value: false

   Example:

     files:

       "/tmp/testcopy"

         copy_from    => mycopy("/tmp/source"),
         move_obstructions => "true",
         depth_search => recurse("inf");

   Notes: Some operating systems (Solaris) use symbolic links in path names.
   Copying to a directory could then result in renaming of the important
   link, if the behavior is different.

  pathtype

   Description: Menu option for interpreting promiser file object

   By default, CFEngine makes an educated guess as to whether the promise
   pathname involves a regular expression or not. This guesswork is needed
   due to cross-platform differences in filename interpretation.

   If CFEngine guesses (or is told) that the pathname uses a regular
   expression pattern, it will undertake a file search to find possible
   matches. This can consume significant resources, and so the guess option
   will always try to optimize this. Guesswork is, however, imperfect, so you
   have the option to declare your intention.

   Type: (menu option)

   Allowed input range:

     literal
     regex
     guess

   If the keyword literal is invoked, a path will be treated as a literal
   string regardless of what characters it contains. If it is declared regex,
   it will be treated as a pattern to match.

   Note that CFEngine splits the promiser up into path links before matching,
   so that each link in the path chain is matched separately. Thus it it
   meaningless to have a / in a regular expression, as the comparison will
   never see this character.

   Default value: guess

   Example:

 files:

    "/var/lib\d"
       pathtype => "guess",  # best guess (default)
          perms => system;

    "/var/lib\d"
       pathtype => "regex",  # force regex interpretation
          perms => system;

    "/var/.*/lib"

       pathtype => "literal",    # force literal interpretation
          perms => system;

   In these examples, at least one case implies an iteration over all
   files/directories matching the regular expression, while the last case
   means a single literal object with a name composed of dots and stars.

   Notes:
   On Windows paths using regex must use the forward slash (/) as path
   separator, since the backward slash has a special meaning in a regular
   expression. Literal paths may also use backslash (\) as a path separator.

  perms

   Type: body perms

    bsdflags

   Description: List of menu options for BSD file system flags to set

   Type: slist

   Allowed input range:
   [+-]*[(arch|archived|nodump|opaque|sappnd|sappend|schg|schange|simmutable|sunlnk|sunlink|uappnd|uappend|uchg|uchange|uimmutable|uunlnk|uunlink)]+

   Example:

      body perms example
      {
      bsdflags => { "uappnd","uchg","uunlnk","nodump",
                    "opaque","sappnd","schg","sunlnk" };
      }

   Notes: The BSD Unices (FreeBSD, OpenBSD, NetBSD) and MacOSX have
   additional file system flags which can be set. Refer to the BSD chflags
   documentation for this.

    groups

   Description: List of acceptable groups of group ids, first is change
   target

   The first named group in the list is the default that will be configured
   if the file does not match an element of the list. The reserved word none
   may be used to match files that are not owned by a registered group.

   Type: slist

   Allowed input range: [a-zA-Z0-9_$.-]+

   Example:

      body perms example
      {
      groups => { "users", "administrators" };
      }

   Notes: On Windows, files do not have file groups associated with them, and
   thus this attribute is ignored. ACLs may be used in place for this.

    mode

   Description: File permissions

   The mode string may be symbolic or numerical, like chmod.

   Type: string

   Allowed input range: [0-7augorwxst,+-]+

   Example:

      body perms example
      {
      mode => "a+rx,o+w";
      }

   Notes: This is ignored on Windows, as the permission model uses ACLs.

    owners

   Description: List of acceptable owners or user ids, first is change target

   The first user is the reference value that CFEngine will set the file to
   if none of the list items matches the true state of the file. The reserved
   word none may be used to match files that are not owned by a registered
   user.

   Type: slist

   Allowed input range: [a-zA-Z0-9_$.-]+

   Example:

      body perms example
      {
      owners => { "mark", "wwwrun", "jeang" };
      }

   Notes: On Windows, users can only take ownership of files, never give it.
   Thus, the first user in the list should be the user running the CFEngine
   process (usually Administrator). Additionally, some groups may be owners
   on Windows (such as the Administrators group).

    rxdirs

   Description: true/false add execute flag for directories if read flag is
   set

   Default behavior is to set the x flag on directories automatically if the
   r flag is specified.

   Type: boolean

   Example:

      body perms rxdirs
      {
      rxdirs => "false";
      }

   Notes: This is ignored on Windows, as the permission model uses ACLs.

  rename

   Type: body rename

    disable

   Description: true/false automatically rename and remove permissions

   Disabling a file means making it unusable. For executables this means
   preventing execution, for an information file it means making the file
   unreadable.

   Type: boolean

   Default value: false

   Example:

      body rename example
      {
      disable => "true";
      disable_suffix => ".nuked";
      }

    disable_mode

   Description: The permissions to set when a file is disabled

   To disable an executable it is not enough to rename it, you should also
   remove the executable flag.

   Type: string

   Allowed input range: [0-7augorwxst,+-]+

   Example:

      body rename example
      {
      disable_mode => "0600";
      }

    disable_suffix

   Description: The suffix to add to files when disabling

   To disable files in a particular manner, use this string suffix.

   Type: string

   Allowed input range: (arbitrary string)

   Default value: .cfdisabled

   Example:

      body rename example
      {
      disable => "true";
      disable_suffix => ".nuked";
      }

    newname

   Description: The desired name for the current file

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body rename example(s)
      {
      newname => "$(s)";
      }

    rotate

   Description: Maximum number of file rotations to keep

   Used for log rotation. If the file is named foo and the rotate attribute
   is set to 4, as above, then initially foo is copied to foo.1 and the old
   file foo is zeroed out (that is, the inode of the original logfile does
   not change, but the original log file will be empty after the rotation is
   complete).

   The next time the promise is executed, foo.1 will be renamed foo.2, foo is
   again copied to foo.1 and the old file foo is again zeroed out.

   Each time the promise is executed (and typically, the promise would be
   executed as guarded by time-based or file-size-based classes), the files
   are copied/zeroed or rotated as above until there are rotate numbered
   files plus the one "main" file.

   Type: int

   Allowed input range: 0,99

   Example:

      body rename example
      {
      rotate => "4";
      }

   In the example above, the file foo.3 will be renamed foo.4, but the old
   version of the file foo.4 will be deleted (that is, it "falls off the end"
   of the rotation).

  repository

   Description: Name of a repository for versioning

   A local repository for this object, overrides the default.

   Note that when a repository is specified, the files are stored using the
   canonified directory name of the original file, concatenated with the name
   of the file. So, for example, /usr/local/etc/postfix.conf would ordinarily
   be stored in an alternative repository as
   _usr_local_etc_postfix.conf.cfsaved.

   Type: string

   Allowed input range: "?(/.*)

   Example:

     files:

      "/path/file"

        copy_from => source,
        repository => "/var/cfengine/repository";

  touch

   Description: true/false whether to touch time stamps on file

   Type: boolean

   Example:

     files:

      "/path/file"

        touch => "true";

  transformer

   Description: Command (with full path) used to transform current file (no
   shell wrapper used)

   A command to execute, usually for the promised file to transform it to
   something else (but possibly to create the promised file based on a
   different origin file).

   The promiser file must exist in order to effect the transformer.

   Note also that if you use the $(this.promiser) variable or other variable
   in this command, and the file object contains spaces, then you should
   quote the variable. For example:

     transformer => "/usr/bin/gzip \"$(this.promiser)\"",

   Note also that the transformer does not actually need to change the file.
   You can, for example, simply report on the existence of files with:

     transformer => "/bin/echo I found a file named $(this.promiser)",

   The file streams stdout and stderr are redirected by CFEngine, and will
   not appear in any output unless you run cf-agent with the -v switch.

   It is possible to set classes based on the return code of a
   transformer-command in a very flexible way. See the kept_returncodes,
   repaired_returncodes and failed_returncodes attributes.

   Finally, you should note that the command is not run in a shell. This
   means that you cannot perform file redirection or create pipelines.

   Type: string

   Allowed input range: "?(/.*)

   Example:

   These examples show both types of promises.

     files:
       "/home/mark/tmp/testcopy"

         file_select => pdf_files,
         transformer => "/usr/bin/gzip $(this.promiser)",
         depth_search => recurse("inf");

   In the first example, the promise is made on the file that we wish to
   transform. If the promised file exists, the transformer will change the
   file to a compressed version (and the next time CFEngine runs, the
   promised file will no longer exist, because it now has the .gz extension).

      classes:
         "do_update" expression => isnewerthan("/etc/postfix/alias",
                                               "/etc/postfix/alias.cdb");

      files:
         "/etc/postfix/alias.cdb"
            create => "true",        # Must have this!
            transformer => "/usr/sbin/postalias /etc/postfix/alias",
            ifvarclass => "do_update";

   In the second example, the promise is made on the file resulting from the
   transformation (and the promise is conditional on the original file being
   newer than the result file). In this case, we must specify create = true.
   If we do not, then if the promised file is removed the transformer will
   not be executed.

   -^
*cf3-services*

   A service is a set of zero or more processes. It can be zero if the
   service is not currently running. Services run in the background, and do
   not require user intervention.

   Service promises may be viewed as an abstraction of process and commands
   promises. An important distinguisher is however that a single service may
   consist of multiple processes. Additionally, services are registered in
   the operating system in some way, and get a unique name. Unlike processes
   and commands promises, this makes it possible to use the same name both
   when it is running and not.

   Some operating systems are bundled with a lot of unused services that are
   running as default. At the same time, faulty or inherently insecure
   services are often the cause of security issues. With CFEngine, one can
   create promises stating the services that should be stopped and disabled.

   The operating system may start a service at boot time, or it can be
   started by CFEngine. Either way, CFEngine will ensure that the service
   maintains the correct state (started, stopped, or disabled). On some
   operating systems, CFEngine also allows services to be started on demand,
   when they are needed. This is implemented though the inetd or xinetd
   daemon on Unix. Windows does not support this.

   CFEngine also allows for the concept of dependencies between services, and
   can automatically start or stop these, if desired. Parameters can be
   passed to services that are started by CFEngine.

     bundle agent example
     {
     services:

       "Dhcp"
         service_policy => "start",
         service_dependencies => { "Alerter", "W32Time" },
         service_method => winmethod;
     }

     body service_method winmethod
     {
       service_type => "windows";
       service_args => "--netmask=255.255.0.0";
       service_autostart_policy => "none";
       service_dependence_chain => "start_parent_services";
     }

   Note: Services promises for Windows are only available in CFEngine
   Enterprise. Windows Vista/Server 2008 and later introduced new
   complications to the service security policy. Therefore, when testing
   services promises from the command line, CFEngine may not be given proper
   access rights, which gives errors like "Access is denied". However, when
   running through the CFEngine Enterprise Executor service, typical for on
   production machines, CFEngine has sufficient rights.

   Services of type generic promises are implemented for all operating
   systems and are merely as a convenient front-end to processes and
   commands. If nothing else is specified, CFEngine looks for an special
   reserved agent bundle called

     bundle agent standard_services(service,state)
     {
     ...
     }

   This bundle is called with two parameters: the name of the service and a
   start/stop state variable. The CFEngine standard library defines many
   common services for standard operating systems for convenience. If no
   service_bundle is defined in a service_method body, then CFEngine assumes
   the standard_services bundle to be the default source of action for the
   services. This is executed just like a methods promise on the service
   bundle, so this is merely a front-end.

   The standard bundle can be replaced with another, as follows:

     bundle agent test
     {
     vars:

      "mail" slist => { "spamassassin", "postfix" };

     services:

       "www" service_policy => "start",
             service_method => service_test;

       "$(mail)" service_policy => "stop",
             service_method => service_test;
     }

     body service_method service_test
     {
       service_bundle => non_standard_services("$(this.promiser)","$(this.service_policy)");
     }

     bundle agent non_standard_services(service,state)
     {
     reports:

       !done::

         "Test service promise for \"$(service)\" -> $(state)";
     }

   Note that the special variables $(this.promiser) and
   $(this.service_policy) may be used to fill in the service and state
   parameters from the promise definition. The $(this.service_policy)
   variable is only defined for services promises.

   History: This promise type was introduced in CFEngine 3.3.0 (2012).

     ----------------------------------------------------------------------

Attributes

  service_policy

   Description: Policy for CFEngine service status.

   If set to start, CFEngine will keep the service in a running state, while
   stop means that the service is kept in a stopped state. disable implies
   stop, and ensures that the service can not be started directly, but needs
   to be enabled somehow first (e.g. by changing file permissions).

   Type: (menu option)

   Allowed input range:

     start
     stop
     disable
     restart
     reload

   Example:

 services:

   "Telnet"
      service_policy => "disable";

  service_dependencies

   Description: A list of services on which the named service abstraction
   depends

   A list of services that must be running before the service can be started.
   These dependencies can be started automatically by CFEngine if they are
   not running see service_dependence_chain. However, the dependencies will
   never be implicitly stopped by CFEngine. Specifying dependencies is
   optional.

   Note that the operating system may keep an additional list of dependencies
   for a given service, defined during installation of the service. CFEngine
   requires these dependencies to be running as well before starting the
   service. The complete list of dependencies is thus the union of
   service_dependencies and the internal operating system list.

   Type: slist

   Allowed input range: [a-zA-Z0-9_$(){}\[\].:]+

   Example:

 services:

   "ftp"
     service_policy => "start",
     service_dependencies => { "network", "logging" };

  service_method

   Type: body service_method

    service_args

   Description: Parameters for starting the service as command

   These arguments will only be passed if CFEngine starts the service. Thus,
   set service_autostart_policy to none to ensure that the arguments are
   always passed.

   Escaped quotes can be used to pass an argument containing spaces as a
   single argument, e.g. -f \"file name.conf\". Passing arguments is
   optional.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body service_method example
      {
        service_args => "-f filename.conf --some-argument";
      }

    service_autostart_policy

   Description: Should the service be started automatically by the OS

   Defaults to none, which means that the service is not registered for
   automatic startup by the operating system in any way. It must be none if
   service_policy is not start. boot_time means the service is started at
   boot time, while on_demand means that the service is dispatched once it is
   being used.

   Type: (menu option)

   Allowed input range:

     none
     boot_time
     on_demand

   Example:

      body service_method example
      {
        service_autostart_policy => "boot_time";
      }

   Notes: on_demand is not supported by Windows, and is implemented through
   inetd or xinetd on Unix.

    service_bundle

   Type: bundle agent

    service_dependence_chain

   Description: How to handle dependencies and dependent services

   The service dependencies include both the dependencies defined by the
   operating system and in service_dependencies, as described there.

   Defaults to ignore, which means that CFEngine will never start or stop
   dependencies or dependent services, but fail if dependencies are not
   satisfied. start_parent_services means that all dependencies of the
   service will be started if they are not already running. When stopping a
   service, stop_child_services means that other services that depend on this
   service will be stopped also. all_related means both start_parent_services
   and stop_child_services.

   Note that this setting also affects dependencies of dependencies and so
   on.

   For example, consider the case where service A depends on B, which depends
   on C. If we want to start B, we must first make sure A is running. If
   start_parent_services or all_related is set, CFEngine will start A, if it
   is not running. On the other hand, if we want to stop B, C needs to be
   stopped first. stop_child_services or all_related means that CFEngine will
   stop C, if it is running.

   Type: (menu option)

   Allowed input range:

     ignore
     start_parent_services
     stop_child_services
     all_related

   Example:

      body service_method example
      {
        service_dependence_chain => "start_parent_services";
      }

    service_type

   Description: Service abstraction type

   Type: (menu option)

   Allowed input range:

     windows
     generic

   Example:

      body service_method example
      {
        service_type => "windows";
      }

   Notes: On Windows this defaults to, and must be windows. Unix systems can
   however have multiple means of registering services, but the choice must
   be available on the given system.

   -^
*cf3-defaults*

   Defaults promises are related to variables. If a variable or parameter in
   a promise bundle is undefined, or its value is defined to be invalid, a
   default value can be promised instead.

   CFEngine does not use Perl semantics: i.e. undefined variables do not map
   to the empty string, they remain as variables for possible future
   expansion. Some variables might be defined but still contain unresolved
   variables. To handle this you will need to match the $(abc) form of the
   variables.

     body common control
     {
     bundlesequence => { "main" };
     }

     bundle agent main
     {
     methods:

       "example"  usebundle => test("one","x","","$(four)");

     }

     bundle agent test(a,b,c,d)
     {
     defaults:

      "a" string => "default a", if_match_regex => "";
      "b" string => "default b", if_match_regex => "x";
      "c" string => "default c", if_match_regex => "";
      "d" string => "default d", if_match_regex => "\$\([a-zA-Z0-9_.]+\)";

     reports:

        "a = '$(a)', b = '$(b)', c = '$(c)' d = '$(d)'";
     }

   Another example:

 bundle agent example
 {
 defaults:

   "X" string => "I am a default value";
   "Y" slist => { "I am a default list item 1", "I am a default list item 2" };

 methods:

  "example" usebundle => mymethod("","bbb");

 reports:

    "The default value of X is $(X)";
    "The default value of Y is $(Y)";
 }

 ###########################################################

 bundle agent mymethod(a,b)
 {
 vars:

   "no_return" string => "ok"; # readfile("/dont/exist","123");

 defaults:

   "a" string => "AAAAAAAAA",   if_match_regex => "";
   "b" string => "BBBBBBBBB",   if_match_regex => "";
   "no_return" string => "no such file";

 reports:

      "The value of a is $(a)";
      "The value of b is $(b)";

      "The value of no_return is $(no_return)";
 }

     ----------------------------------------------------------------------

Attributes

  if_match_regex

   Description: If this regular expression matches the current value of the
   variable, replace it with default

   If a parameter or variable is already defined in the current context, and
   the value matches this regular expression, it will be deemed invalid and
   replaced with the default value.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

     bundle agent mymethod(a,b)
     {
     defaults:

       "a" string => "AAAAAAAAA",   if_match_regex => "";
       "b" string => "BBBBBBBBB",   if_match_regex => "";
     }

   -^
*cf3-roles*

   Roles promises are server-side decisions about which users are allowed to
   define soft-classes on the server's system during remote invocation of
   cf-agent. This implements a form of Role Based Access Control (RBAC) for
   pre-assigned class-promise bindings. The user names cited must be attached
   to trusted public keys in order to be accepted. The regular expression is
   anchored, meaning it must match the entire name.

     roles:

     "regex"

        authorize = { "usernames", ... };

   It is worth re-iterating here that it is not possible to send commands or
   modify promise definitions by remote access. At best users may try to send
   classes when using cf-runagent in order to activate sleeping promises.
   This mechanism limits their ability to do this.

 bundle server access_rules()

 {
 roles:

   # Allow mark

   "Myclass_.*"  authorize => { "mark" };
 }

   In this example user mark is granted permission to remotely activate
   classes matching the regular expression Myclass_.* hen using the
   cf-runagent to activate CFEngine.

     ----------------------------------------------------------------------

Attributes

  authorize

   Description: List of public-key user names that are allowed to activate
   the promised class during remote agent activation

   Part of Role Based Access Control (RBAC) in CFEngine. The users listed in
   this section are granted access to set certain classes by using the remote
   cf-runagent. The user-names will refer to public key identities already
   trusted on the system.

   Type: slist

   Allowed input range: (arbitrary string)

   Example:

     roles:

       ".*"  authorize => { "mark", "marks_friend" };

   -^
*cf3-commands*

   Commands and processes are separated cleanly. Restarting of processes must
   be coded as a separate command. This stricter type separation allows for
   more careful conflict analysis to be carried out.

      commands:

        "/path/to/command args"

                   args = "more args",
                   contain = contain_body,
                   module = true/false;

   Output from commands executed here is quoted inline, but prefixed with the
   letter Q to distinguish it from other output; for example, from reports,
   which is prefixed with the letter R.

   It is possible to set classes based on the return code of a
   commands-promise in a very flexible way. See the kept_returncodes,
   repaired_returncodes and failed_returncodes attributes.

 bundle agent example

 {
 commands:

   "/bin/sleep 10"
      action  => background;

   "/bin/sleep"
      args => "20",
      action  => background;

 }

   When referring to executables whose paths contain spaces, you should quote
   the entire program string separately so that CFEngine knows the name of
   the executable file. For example:

       commands:

        windows::

         "\"c:\Program Files\my name with space\" arg1 arg2";

        linux::

         "\"/usr/bin/funny command name\" -a -b -c";

     ----------------------------------------------------------------------

Attributes

  args

   Description: Allows to separate the arguments to the command from the
   command itself.

   Sometimes it is convenient to separate command and arguments. The final
   arguments are the concatenation with one space.

   Type: string

   Allowed input range: (arbitrary string)

 commands:

   "/bin/echo one"

    args => "two three";

   So in the example above the command would be:

  /bin/echo one two three

  contain

   Description: Allows running the command in a 'sandbox'.

   Command containment allows you to make a `sandbox' around a command, to
   run it as a non-privileged user inside an isolated directory tree.

   Type: body contain

   Example:

     body contain example
     {
         useshell => "noshell";
            umask => "077";
       exec_owner => "mysql_user";
       exec_group => "nogroup";
     exec_timeout => "60";          
            chdir => "/working/path";
           chroot => "/private/path";
     }

    useshell

   Description: Specifies which shell to use when executing the command.

   The default is to not use a shell when executing commands. Use of a shell
   has both resource and security consequences. A shell consumes an extra
   process and inherits environment variables, reads commands from files and
   performs other actions beyond the control of CFEngine.

   If one does not need shell functionality such as piping through multiple
   commands then it is best to manage without it. In the Windows version of
   CFEngine Enterprise, the command is run in the cmd Command Prompt if this
   attribute is set to useshell, or in the PowerShell if the attribute is set
   to powershell.

   Type: (menu option)

   Allowed input range:

     useshell
     noshell
     powershell

   For compatibility, the boolean values are also supported, and map to
   useshell and noshell, respectively.

   Default value: noshell

   Example:

      body contain example
      {
      useshell => "useshell";
      }

    umask

   Description: Sets the internal umask for the process.

   Default value for the mask is 077. On Windows, umask is not supported and
   is thus ignored by Windows versions of CFEngine.

   Type: (menu option)

   Allowed input range:

     0
     77
     22
     27
     72
     077
     022
     027
     072

   Example:

      body contain example
      {
      umask => "077";
      }

    exec_owner

   Description: Specifies the user under which the command executes.

   This is part of the restriction of privilege for child processes when
   running cf-agent as the root user, or a user with privileges.

   Windows requires the clear text password for the user account to run
   under. Keeping this in CFEngine policies could be a security hazard.
   Therefore, this option is not yet implemented on Windows versions of
   CFEngine.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body contain example
      {
      exec_owner => "mysql_user";
      }

    exec_group

   Description: Associates the command with a group.

   This is part of the restriction of privilege for child processes when
   running cf-agent as the root group, or a group with privileges. It is
   ignored on Windows, as processes do not have any groups associated with
   them.

   Type: string

   Allowed input range: (arbitrary string)

   Example:

      body contain example
      {
      exec_group => "nogroup";
      }

    exec_timeout

   Description: Attempt to time-out after this number of seconds.

   This cannot be guaranteed as not all commands are willing to be
   interrupted in case of failure.

   Type: int

   Allowed input range: 1,3600

   Example:

      body contain example
      {
      exec_timeout => "30";
      }

    chdir

   Description: Run the command with a working directory.

   This attribute has the effect of placing the running command into a
   current working directory equal to the parameter given; in other words, it
   works like the cd shell command.

   Type: string

   Allowed input range: "?(/.*)

   Example:

      body contain example

      {
      chdir => "/containment/directory";
      }

    chroot

   Description: Specify the path that will be the root directory for the
   process.

   The path of the directory will be experienced as the top-most root
   directory for the process. In security parlance, this creates a 'sandbox'
   for the process. Windows does not support this feature.

   Type: string

   Allowed input range: "?(/.*)

   Example:

      body contain example

      {
      chroot => "/private/path";
      }

    preview

   Description: This is the preview command when running in dry-run mode
   (with -n).

   Previewing shell scripts during a dry-run is a potentially misleading
   activity. It should only be used on scripts that make no changes to the
   system. It is CFEngine best practice to never write change-functionality
   into user-written scripts except as a last resort. CFEngine can apply its
   safety checks to user defined scripts.

   Type: boolean

   Default value: false

   Example:

      body contain example
      {
      preview => "true";
      }

    no_output

   Description: Allows to discard all output from the command.

   Setting this attribute to true is equivalent to piping standard output and
   error to /dev/null.

   Type: boolean

   Default value: false

   Example:

      body contain example
      {
      no_output => "true";
      }

  module

   Description: Set variables and classes based on command output.

   CFEngine modules are commands that support a simple protocol in order to
   set additional variables and classes on execution from user defined code.
   Modules are intended for use as system probes rather than additional
   configuration promises. Such a module may be written in any language.

   This attribute determines whether or not to expect the CFEngine module
   protocol. If true, the module protocol is supported for this command:

     * lines which begin with a + are treated as classes to be defined (like
       -D)
     * lines which begin with a - are treated as classes to be undefined
       (like -N)
     * lines which begin with = are scalar variables to be defined
     * lines which begin with @ are lists.

   These variables end up in a context that has the same name as the module.

   Any other lines of output are cited by cf-agent as being erroneous, so you
   should normally make your module completely silent.

   Type: boolean

   Default value: false

   Example:

   Here is an example module written in shell:

      #!/bin/sh
      /bin/echo "@mylist= { \"one\", \"two\", \"three\" }"
      /bin/echo "=myscalar= scalar val"
      /bin/echo "+module_class"

   And here is an example using it:

     body common control
     {
     bundlesequence  => { def, modtest };
     }

     bundle agent def
     {
     commands:

       "$(sys.workdir)/modules/module_name"
         module => "true";

     reports:

       # Each module forms a private context with its name as id
       module_class::

         "Module set variable $(module_name.myscalar)";
     }


     bundle agent modtest
     {
     vars:

       "mylist" slist => { @(module_name.mylist) };

     reports:

       module_class::

         "Module set variable $(mylist)";
     }

   Here is an example module written in Perl:

      #!/usr/bin/perl
      #
      # module:myplugin
      #

        # lots of computation....

      if (special-condition)
         {
         print "+specialclass";
         }

   If your module is simple and is best expressed as a shell command, then we
   suggest that you expose the class being defined in the command being
   executed (making it easier to see what classes are used when reading the
   promises file). For example, the promises could read as follows (the two
   echo commands are to ensure that the shell always exits with a successful
   execution of a command):

     bundle agent sendmail
     {
     commands:
       # This next module checks a specific failure mode of dcc, namely
       # more than 3 error states since the last time we ran cf-agent
       is_mailhost::
             "/bin/test `/usr/bin/tail -100 /var/log/maillog | /usr/bin/grep 'Milter (dcc): to error state' | /usr/bin/wc -l` -gt 3  echo '+start_dccm' || echo
     ''"
         contain => shell_command,
         module => "true";

         start_dccm::
           "/var/dcc/libexec/start-dccm"
               contain => not_paranoid;
     }

     body contain shell_command
     {
         useshell    => "useshell";
     }

     body contain not_paranoid
     {
         useshell    => "no";
         exec_owner  => "root";
         umask       => "22";
     }

   Modules inherit the environment variables from cf-agent and accept
   arguments, just as a regular command does.

   -^
